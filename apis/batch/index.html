<!--
Licensed to the Apache Software Foundation (ASF) under one
or more contributor license agreements.  See the NOTICE file
distributed with this work for additional information
regarding copyright ownership.  The ASF licenses this file
to you under the Apache License, Version 2.0 (the
"License"); you may not use this file except in compliance
with the License.  You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing,
software distributed under the License is distributed on an
"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, either express or implied.  See the License for the
specific language governing permissions and limitations
under the License.
-->
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <title>Apache Flink 1.1.0 中文文档: Flink DataSet API 编程指南</title>
    <link rel="shortcut icon" href="/1.1.0/page/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/1.1.0/page/favicon.ico" type="image/x-icon">

    <!-- Bootstrap -->
    <link href="//cdn.bootcss.com/bootstrap/3.3.4/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="/1.1.0/page/css/flink.css">
    <link rel="stylesheet" href="/1.1.0/page/css/syntax.css">
    <link rel="stylesheet" href="/1.1.0/page/css/codetabs.css">
    
    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  </head>
  <body>
    
    
    <div style="position:fixed; bottom:0; left:0; z-index:99999; width:100%; text-align:center; padding:15px; border-top:1px dashed #CE4B65; background:#f6f0e3; font-weight:bold">
       本文档适用于 Apache Flink 的旧版本，建议使用 <a href="http://doc.flink-china.org/latest/">最新版本的文档</a> 。
    </div>
    
    

    
    





    <!-- Top navbar. -->
    <nav class="navbar navbar-default navbar-fixed-top">
      <div class="container">
        <!-- The logo. -->
        <div class="navbar-header">
          <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <div class="navbar-logo">
            <a href="http://flink-china.org"><img alt="Apache Flink" src="/1.1.0/page/img/navbar-brand-logo.jpg"></a>
          </div>
        </div><!-- /.navbar-header -->

        <!-- The navigation links. -->
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
          <ul class="nav navbar-nav">
            <li class="hidden-sm "><a href="/1.1.0/">中文文档 1.1</a></li>

            <li class="hidden-sm "><a href="/1.1.0/features.html">特性</a></li>

            <!-- Quickstart -->
            <li class="dropdown">
              <a href="/1.1.0/quickstart" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">快速起步<span class="caret"></span></a>
              <ul class="dropdown-menu" role="menu">
                
                
                <li class=""><a href="/1.1.0/quickstart/setup_quickstart.html">安装</a></li>
                
                <li class=""><a href="/1.1.0/quickstart/run_example_quickstart.html">例子: 维基百科编辑流</a></li>
                
                <li class=""><a href="/1.1.0/quickstart/java_api_quickstart.html">Java API</a></li>
                
                <li class=""><a href="/1.1.0/quickstart/scala_api_quickstart.html">Scala API</a></li>
                
              </ul>
            </li>

            <!-- Setup -->
            <li class="dropdown">
              <a href="/1.1.0/setup" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">安装 <span class="caret"></span></a>
              <ul class="dropdown-menu" role="menu">
                
                
                <li class=""><a href="/1.1.0/setup/building.html">构建 Flink</a></li>
                
                <li class=""><a href="/1.1.0/setup/config.html">Configuration</a></li>
                

                <li class="divider"></li>
                <li role="presentation" class="dropdown-header"><strong>部署</strong></li>
                
                
                <li class=""><a href="/1.1.0/setup/local_setup.html">本地</a></li>
                
                <li class=""><a href="/1.1.0/setup/cluster_setup.html">集群 (Standalone)</a></li>
                
                <li class=""><a href="/1.1.0/setup/yarn_setup.html">YARN</a></li>
                
                <li class=""><a href="/1.1.0/setup/gce_setup.html">Google Compute Engine</a></li>
                
                <li class=""><a href="/1.1.0/setup/jobmanager_high_availability.html">High Availability</a></li>
                
              </ul>
            </li>

            <!-- Programming Guides -->
            <li class="dropdown active">
              <a href="/1.1.0/apis" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">编程指南 <span class="caret"></span></a>
              <ul class="dropdown-menu" role="menu">
                
                
                <li class=""><a href="/1.1.0/apis/common/"><strong>基本概念</strong></a></li>
                
                <li class=""><a href="/1.1.0/apis/streaming/"><strong>Streaming 指南</strong> (DataStream API)</a></li>
                
                <li class="active"><a href="/1.1.0/apis/batch/"><strong>Batch 指南</strong> (DataSet API)</a></li>
                
                <li class=""><a href="/1.1.0/apis/best_practices.html">Best Practices</a></li>
                
                <li class=""><a href="/1.1.0/apis/cli.html">命令行接口（CLI）</a></li>
                
                <li class=""><a href="/1.1.0/apis/local_execution.html">本地执行</a></li>
                
                <li class=""><a href="/1.1.0/apis/cluster_execution.html">Cluster Execution</a></li>
                
                <li class=""><a href="/1.1.0/apis/scala_shell.html">Scala Shell</a></li>
                
                <li class=""><a href="/1.1.0/apis/java8.html">Java 8</a></li>
                
                <li class=""><a href="/1.1.0/apis/metrics.html">Metrics</a></li>
                
              </ul>
            </li>

            <!-- Libraries -->
            <li class="dropdown">
              <a href="/1.1.0/libs" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">类库 <span class="caret"></span></a>
                <ul class="dropdown-menu" role="menu">
                  
                  
                  <li class=""><a href="/1.1.0/apis/batch/libs/gelly.html">Graphs: Gelly</a></li>
                  
                  <li class=""><a href="/1.1.0/apis/streaming/libs/cep.html">CEP</a></li>
                  
                  <li class=""><a href="/1.1.0/apis/batch/libs/ml/">Machine Learning</a></li>
                  
                  <li class=""><a href="/1.1.0/apis/batch/libs/table.html">Relational: Table</a></li>
                  
              </ul>
            </li>

            <!-- Internals -->
            <li class="dropdown">
              <a href="/1.1.0/internals" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">内部 <span class="caret"></span></a>
              <ul class="dropdown-menu" role="menu">
                <li role="presentation" class="dropdown-header"><strong>Contribute</strong></li>
                <li><a href="http://flink.apache.org/how-to-contribute.html"><small><span class="glyphicon glyphicon-new-window"></span></small> How to Contribute</a></li>
                <li><a href="http://flink.apache.org/contribute-code.html#coding-guidelines"><small><span class="glyphicon glyphicon-new-window"></span></small> Coding Guidelines</a></li>
                
                
                <li class=""><a href="/1.1.0/internals/ide_setup.html">IDE Setup</a></li>
                
                <li class=""><a href="/1.1.0/internals/logging.html">Logging</a></li>
                
                <li class=""><a href="/1.1.0/internals/general_arch.html">Architecture and Process Model</a></li>
                
                <li class=""><a href="/1.1.0/internals/stream_checkpointing.html">Data Streaming的容错机制</a></li>
                
                <li class=""><a href="/1.1.0/internals/types_serialization.html">Type Extraction and Serialization</a></li>
                
                <li class=""><a href="/1.1.0/internals/monitoring_rest_api.html">Monitoring REST API</a></li>
                
                <li class=""><a href="/1.1.0/internals/job_scheduling.html">Jobs and Scheduling</a></li>
                
                <li class=""><a href="/1.1.0/internals/add_operator.html">How-To: Add an Operator</a></li>
                
              </ul>
            </li>

          </ul>
          <ul class="nav navbar-nav navbar-right">
            <li><a class="hidden-sm" href="http://blog.flink-china.org" target="_blank">
            <small><span class="glyphicon glyphicon-new-window"></span></small> 博客</a></li>
            <li class="hidden-sm "><a href="/1.1.0/about/">关于本站</a></li>
          </ul>
          <form class="navbar-form navbar-right hidden-sm hidden-md" role="search" action="/1.1.0/search-results.html">
            <div class="form-group">
              <input type="text" class="form-control" size="16px" name="q" placeholder="Search all pages">
            </div>
            <button type="submit" class="btn btn-default">搜索</button>
          </form>
        </div><!-- /.navbar-collapse -->
      </div><!-- /.container -->
    </nav>


    

    <!-- Main content. -->
    <div class="container">
      
      
<div class="row">


  <!-- Sub Navigation -->
  <div class="col-sm-3">
    <ul id="sub-nav">
      
      
      
    </ul>
  </div>
  <!-- Main -->
  <div class="col-sm-9">
    <!-- Top anchor -->
    <a href="#top"></a>

    <!-- Artifact name change warning. Remove for the 1.0 release. -->
    
    <div class="panel panel-default">
      <div class="panel-body"><strong>重要</strong>: 依赖于Scala的maven artifacts现在会添加一个Scala主版本的后缀，例如 "2.10" 或 "2.11". 请查阅<a href="https://cwiki.apache.org/confluence/display/FLINK/Maven+artifact+names+suffixed+with+Scala+version">迁移指南</a>.</div>
    </div>
    

    <!-- Breadcrumbs above the main heading -->
    <ol class="breadcrumb">
      

      
      <li class="active">DataSet API</li>
    </ol>

    <div class="text">
      <!-- Main heading -->
      <h1>Flink DataSet API 编程指南</h1>

      <!-- Content -->
      

<p>DataSet 程序是 Flink 实现了数据集上的转换操作（如 filtering, mapping, joining, grouping 等）的普通程序。初始数据集是从特定的数据源（例如文件或集合）中创建出来的。
通过sink来返回结果，它有可能把结果写到（分布式）文件或标准输出（比如命令行终端）。
Flink 可以运行在各种环境中， 比如 standalone，或嵌入到其他程序中。可以在本地 JVM 或集群上运行 Flink 程序。</p>

<p>如果想要学习DataSet,建议从<a href="/1.1.0/apis/common/index.html">基本概念</a>和<a href="/1.1.0/apis/common/index.html#anatomy-of-a-flink-program">剖析 Flink 程序</a>开始入手，并逐步增加自己的<a href="#dataset-transformations">转换操作</a>。其他章节将介绍额外的操作或高级特性。</p>

<ul id="markdown-toc">
  <li><a href="#示例程序" id="markdown-toc-示例程序">示例程序</a></li>
  <li><a href="#dataset-转换transformations" id="markdown-toc-dataset-转换transformations">DataSet 转换（Transformations）</a></li>
  <li><a href="#data-sources" id="markdown-toc-data-sources">Data Sources</a>    <ul>
      <li><a href="#read-compressed-files" id="markdown-toc-read-compressed-files">Read Compressed Files</a></li>
    </ul>
  </li>
  <li><a href="#data-sinks" id="markdown-toc-data-sinks">Data Sinks</a></li>
  <li><a href="#iteration-operators" id="markdown-toc-iteration-operators">Iteration Operators</a></li>
  <li><a href="#operating-on-data-objects-in-functions" id="markdown-toc-operating-on-data-objects-in-functions">Operating on data objects in functions</a>    <ul>
      <li><a href="#object-reuse-disabled-default" id="markdown-toc-object-reuse-disabled-default">Object-Reuse Disabled (DEFAULT)</a></li>
      <li><a href="#object-reuse-enabled" id="markdown-toc-object-reuse-enabled">Object-Reuse Enabled</a></li>
    </ul>
  </li>
  <li><a href="#debugging" id="markdown-toc-debugging">Debugging</a>    <ul>
      <li><a href="#local-execution-environment" id="markdown-toc-local-execution-environment">Local Execution Environment</a></li>
      <li><a href="#collection-data-sources-and-sinks" id="markdown-toc-collection-data-sources-and-sinks">Collection Data Sources and Sinks</a></li>
    </ul>
  </li>
  <li><a href="#semantic-annotations" id="markdown-toc-semantic-annotations">Semantic Annotations</a></li>
  <li><a href="#broadcast-variables" id="markdown-toc-broadcast-variables">Broadcast Variables</a></li>
  <li><a href="#passing-parameters-to-functions" id="markdown-toc-passing-parameters-to-functions">Passing Parameters to Functions</a></li>
</ul>

<p><a id="example-program"></a></p>

<h2 id="示例程序">示例程序</h2>

<p>下面的程序是一个完整的、可运行的 WordCount 示例。你可以复制 &amp; 粘贴下方代码并在本地运行。你只需要引入正确的 Flink 依赖到项目中（参见 <a href="/1.1.0/apis/common/#linking-with-flink">关联 Flink</a>）并指定具体的 imports。之后你就可以出发了！</p>

<div class="codetabs">
  <div data-lang="java">

    <figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">WordCountExample</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
        <span class="kd">final</span> <span class="n">ExecutionEnvironment</span> <span class="n">env</span> <span class="o">=</span> <span class="n">ExecutionEnvironment</span><span class="o">.</span><span class="na">getExecutionEnvironment</span><span class="o">();</span>

        <span class="n">DataSet</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">text</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="na">fromElements</span><span class="o">(</span>
            <span class="s">&quot;Who&#39;s there?&quot;</span><span class="o">,</span>
            <span class="s">&quot;I think I hear them. Stand, ho! Who&#39;s there?&quot;</span><span class="o">);</span>

        <span class="n">DataSet</span><span class="o">&lt;</span><span class="n">Tuple2</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;&gt;</span> <span class="n">wordCounts</span> <span class="o">=</span> <span class="n">text</span>
            <span class="o">.</span><span class="na">flatMap</span><span class="o">(</span><span class="k">new</span> <span class="nf">LineSplitter</span><span class="o">())</span>
            <span class="o">.</span><span class="na">groupBy</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
            <span class="o">.</span><span class="na">sum</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>

        <span class="n">wordCounts</span><span class="o">.</span><span class="na">print</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">LineSplitter</span> <span class="kd">implements</span> <span class="n">FlatMapFunction</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Tuple2</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;&gt;</span> <span class="o">{</span>
        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">flatMap</span><span class="o">(</span><span class="n">String</span> <span class="n">line</span><span class="o">,</span> <span class="n">Collector</span><span class="o">&lt;</span><span class="n">Tuple2</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;&gt;</span> <span class="n">out</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="n">String</span> <span class="n">word</span> <span class="o">:</span> <span class="n">line</span><span class="o">.</span><span class="na">split</span><span class="o">(</span><span class="s">&quot; &quot;</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">out</span><span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="k">new</span> <span class="n">Tuple2</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;(</span><span class="n">word</span><span class="o">,</span> <span class="mi">1</span><span class="o">));</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

  </div>

  <div data-lang="scala">

    <figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">import</span> <span class="nn">org.apache.flink.api.scala._</span>

<span class="k">object</span> <span class="nc">WordCount</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">main</span><span class="o">(</span><span class="n">args</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span> <span class="o">{</span>

    <span class="k">val</span> <span class="n">env</span> <span class="k">=</span> <span class="nc">ExecutionEnvironment</span><span class="o">.</span><span class="n">getExecutionEnvironment</span>
    <span class="k">val</span> <span class="n">text</span> <span class="k">=</span> <span class="n">env</span><span class="o">.</span><span class="n">fromElements</span><span class="o">(</span>
      <span class="s">&quot;Who&#39;s there?&quot;</span><span class="o">,</span>
      <span class="s">&quot;I think I hear them. Stand, ho! Who&#39;s there?&quot;</span><span class="o">)</span>

    <span class="k">val</span> <span class="n">counts</span> <span class="k">=</span> <span class="n">text</span><span class="o">.</span><span class="n">flatMap</span> <span class="o">{</span> <span class="k">_</span><span class="o">.</span><span class="n">toLowerCase</span><span class="o">.</span><span class="n">split</span><span class="o">(</span><span class="s">&quot;\\W+&quot;</span><span class="o">)</span> <span class="n">filter</span> <span class="o">{</span> <span class="k">_</span><span class="o">.</span><span class="n">nonEmpty</span> <span class="o">}</span> <span class="o">}</span>
      <span class="o">.</span><span class="n">map</span> <span class="o">{</span> <span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span> <span class="o">}</span>
      <span class="o">.</span><span class="n">groupBy</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
      <span class="o">.</span><span class="n">sum</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>

    <span class="n">counts</span><span class="o">.</span><span class="n">print</span><span class="o">()</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

  </div>

</div>

<p><a href="#top" class="top pull-right"><span class="glyphicon glyphicon-chevron-up"></span> Back to top</a></p>

<p><a id="dataset-transformations"></a></p>

<h2 id="dataset-转换transformations">DataSet 转换（Transformations）</h2>

<p>转换（Transformations) 是将一个或多个 DataSet 转化为一个新的 DataSet。程序可以结合多个转换构建出一个复杂的拓扑。</p>

<p>本节将简要介绍可用的转换。<a href="dataset_transformations.html">转换文档</a>有对所有转换的完整介绍，并附带了例子。</p>

<div class="codetabs">
  <div data-lang="java">

    <table class="table table-bordered">
  <thead>
    <tr>
      <th class="text-left" style="width: 20%">Transformation</th>
      <th class="text-center">Description</th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td><strong>Map</strong></td>
      <td>
        <p>输入一个元素，生成一个元素。</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">data</span><span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="k">new</span> <span class="n">MapFunction</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;()</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="n">Integer</span> <span class="nf">map</span><span class="o">(</span><span class="n">String</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span> <span class="k">return</span> <span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">value</span><span class="o">);</span> <span class="o">}</span>
<span class="o">});</span></code></pre></figure>

      </td>
    </tr>

    <tr>
      <td><strong>FlatMap</strong></td>
      <td>
        <p>输入一个元素，生成零个、一个、或多个元素。</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">data</span><span class="o">.</span><span class="na">flatMap</span><span class="o">(</span><span class="k">new</span> <span class="n">FlatMapFunction</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;()</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">flatMap</span><span class="o">(</span><span class="n">String</span> <span class="n">value</span><span class="o">,</span> <span class="n">Collector</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">out</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">String</span> <span class="n">s</span> <span class="o">:</span> <span class="n">value</span><span class="o">.</span><span class="na">split</span><span class="o">(</span><span class="s">&quot; &quot;</span><span class="o">))</span> <span class="o">{</span>
      <span class="n">out</span><span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">});</span></code></pre></figure>

      </td>
    </tr>

    <tr>
      <td><strong>MapPartition</strong></td>
      <td>
      <p>在一个函数中对一个并行的分区进行转换。该函数将分区以 <code>Iterable</code> 流的形式传入，然后生成任意数量的结果值。每个分区中的元素数量取决于上一个操作的并行度。
      </p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">data</span><span class="o">.</span><span class="na">mapPartition</span><span class="o">(</span><span class="k">new</span> <span class="n">MapPartitionFunction</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Long</span><span class="o">&gt;()</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">mapPartition</span><span class="o">(</span><span class="n">Iterable</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">values</span><span class="o">,</span> <span class="n">Collector</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">&gt;</span> <span class="n">out</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">long</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">String</span> <span class="n">s</span> <span class="o">:</span> <span class="n">values</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">c</span><span class="o">++;</span>
    <span class="o">}</span>
    <span class="n">out</span><span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="n">c</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">});</span></code></pre></figure>

      </td>
    </tr>

    <tr>
      <td><strong>Filter</strong></td>
      <td>
        <p>执行过滤操作，对每个元素进行判断，只保留函数返回为 true 的元素。<br />

        <strong>重要:</strong> 系统假定该方法不会修改元素。违反该假定的话可能会导致错误的结果。
        </p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">data</span><span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="k">new</span> <span class="n">FilterFunction</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;()</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">filter</span><span class="o">(</span><span class="n">Integer</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span> <span class="k">return</span> <span class="n">value</span> <span class="o">&gt;</span> <span class="mi">1000</span><span class="o">;</span> <span class="o">}</span>
<span class="o">});</span></code></pre></figure>

      </td>
    </tr>

    <tr>
      <td><strong>Reduce</strong></td>
      <td>
        <p>通过不断重复合并两个元素到一个元素的操作，将一组元素合并为一个元素。Reduce 可以应用在一个完整的数据集上，或者已分组的数据集上。
        </p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">data</span><span class="o">.</span><span class="na">reduce</span><span class="o">(</span><span class="k">new</span> <span class="n">ReduceFunction</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="n">Integer</span> <span class="nf">reduce</span><span class="o">(</span><span class="n">Integer</span> <span class="n">a</span><span class="o">,</span> <span class="n">Integer</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span> <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="o">;</span> <span class="o">}</span>
<span class="o">});</span></code></pre></figure>

      </td>
    </tr>

    <tr>
      <td><strong>ReduceGroup</strong></td>
      <td>
        <p>将一组元素合并为一个或多个元素。ReduceGroup 可以应用在一个完整的数据集上，或者已分组的数据集上。
        </p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">data</span><span class="o">.</span><span class="na">reduceGroup</span><span class="o">(</span><span class="k">new</span> <span class="n">GroupReduceFunction</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">reduce</span><span class="o">(</span><span class="n">Iterable</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">values</span><span class="o">,</span> <span class="n">Collector</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">out</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">prefixSum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">Integer</span> <span class="n">i</span> <span class="o">:</span> <span class="n">values</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">prefixSum</span> <span class="o">+=</span> <span class="n">i</span><span class="o">;</span>
      <span class="n">out</span><span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="n">prefixSum</span><span class="o">);</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">});</span></code></pre></figure>

      </td>
    </tr>

    <tr>
      <td><strong>Aggregate</strong></td>
      <td>
        <p>将一组值聚合到一个值中。Aggregation 函数可以认为是内建的 reduce 函数。Aggregate 可以应用在一个完整的数据集上，或者已分组的数据集上。
        </p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">Dataset</span><span class="o">&lt;</span><span class="n">Tuple3</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">String</span><span class="o">,</span> <span class="n">Double</span><span class="o">&gt;&gt;</span> <span class="n">input</span> <span class="o">=</span> <span class="c1">// [...]</span>
<span class="n">DataSet</span><span class="o">&lt;</span><span class="n">Tuple3</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">String</span><span class="o">,</span> <span class="n">Double</span><span class="o">&gt;&gt;</span> <span class="n">output</span> <span class="o">=</span> <span class="n">input</span><span class="o">.</span><span class="na">aggregate</span><span class="o">(</span><span class="n">SUM</span><span class="o">,</span> <span class="mi">0</span><span class="o">).</span><span class="na">and</span><span class="o">(</span><span class="n">MIN</span><span class="o">,</span> <span class="mi">2</span><span class="o">);</span></code></pre></figure>

	<p>同时，对于 minimum, maximum, 和 sum 聚合，你也可以使用简写语法。</p>
	
<figure class="highlight"><pre><code class="language-java" data-lang="java">	<span class="n">Dataset</span><span class="o">&lt;</span><span class="n">Tuple3</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">String</span><span class="o">,</span> <span class="n">Double</span><span class="o">&gt;&gt;</span> <span class="n">input</span> <span class="o">=</span> <span class="c1">// [...]</span>
<span class="n">DataSet</span><span class="o">&lt;</span><span class="n">Tuple3</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">String</span><span class="o">,</span> <span class="n">Double</span><span class="o">&gt;&gt;</span> <span class="n">output</span> <span class="o">=</span> <span class="n">input</span><span class="o">.</span><span class="na">sum</span><span class="o">(</span><span class="mi">0</span><span class="o">).</span><span class="na">andMin</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span>
	</code></pre></figure>

      </td>
    </tr>

    <tr>
      <td><strong>Distinct</strong></td>
      <td>
        <p>返回数据集中不重复的元素。去除了输入数据集中在全字段（或字段子集）上重复的元素。
        </p>
    
<figure class="highlight"><pre><code class="language-java" data-lang="java">        <span class="n">data</span><span class="o">.</span><span class="na">distinct</span><span class="o">();</span>
    </code></pre></figure>

      </td>
    </tr>

    <tr>
      <td><strong>Join</strong></td>
      <td>
        Join 两个数据集，生成所有 key 相同的元素对。
        可选地，可以使用 JoinFunction 转换元素对为单个元素，或者使用 FlatJoinFunction 转换元素对为任意多（包括无）的元素。参见 <a href="/1.1.0/apis/common/#specifying-keys">key 章节</a> 了解如何定义 join 的 key。
        

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">result</span> <span class="o">=</span> <span class="n">input1</span><span class="o">.</span><span class="na">join</span><span class="o">(</span><span class="n">input2</span><span class="o">)</span>
               <span class="o">.</span><span class="na">where</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>       <span class="c1">// key of the first input (tuple field 0)</span>
               <span class="o">.</span><span class="na">equalTo</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>    <span class="c1">// key of the second input (tuple field 1)</span></code></pre></figure>

        你可以通过 <i>Join Hints</i> 指定 join 执行的方式。Hint 描述了 join 是否会有分区或广播的发生，以及是否使用了基于排序或基于哈希的算法。请参考 <a href="dataset_transformations.html#join-algorithm-hints">转换指南</a> 了解可用的 hint 列表以及示例。&lt;/br&gt;
        如果没有指定 hint，系统会尝试对输入数据进行估算并根据估算结果选择一个最佳策略。

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="c1">// This executes a join by broadcasting the first data set</span>
<span class="c1">// using a hash table for the broadcasted data</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">input1</span><span class="o">.</span><span class="na">join</span><span class="o">(</span><span class="n">input2</span><span class="o">,</span> <span class="n">JoinHint</span><span class="o">.</span><span class="na">BROADCAST_HASH_FIRST</span><span class="o">)</span>
               <span class="o">.</span><span class="na">where</span><span class="o">(</span><span class="mi">0</span><span class="o">).</span><span class="na">equalTo</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span></code></pre></figure>

        注意 join 转换仅能处理 equi-joins。其他 join 类型需要使用 OuterJoin 或 CoGroup。
      </td>
    </tr>

    <tr>
      <td><strong>OuterJoin</strong></td>
      <td>
      在两个数据集上执行 left/right/full-outer join。Outer join 类似普通的（inner）join，会生成相同 key 的所有元素对。额外的，对于 "outer" （left 或 right 或 full）那一面的记录而言，如果在另一面没有找到匹配的 key，则这些记录都会被保留。匹配的元素对（或一个元素和另一边的一个 <code>null</code> 值）传入到 JoinFunction 中被转成了单个的元素，或传入到 FlatJoinFunction 中被转成了任意多（包括无）的元素。参见 <a href="/1.1.0/apis/common/#specifying-keys">key 章节</a> 了解如何定义 join 的 key。

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">input1</span><span class="o">.</span><span class="na">leftOuterJoin</span><span class="o">(</span><span class="n">input2</span><span class="o">)</span> <span class="c1">// rightOuterJoin or fullOuterJoin for right or full outer joins</span>
      <span class="o">.</span><span class="na">where</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>              <span class="c1">// key of the first input (tuple field 0)</span>
      <span class="o">.</span><span class="na">equalTo</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>            <span class="c1">// key of the second input (tuple field 1)</span>
      <span class="o">.</span><span class="na">with</span><span class="o">(</span><span class="k">new</span> <span class="n">JoinFunction</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">String</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;()</span> <span class="o">{</span>
          <span class="kd">public</span> <span class="n">String</span> <span class="nf">join</span><span class="o">(</span><span class="n">String</span> <span class="n">v1</span><span class="o">,</span> <span class="n">String</span> <span class="n">v2</span><span class="o">)</span> <span class="o">{</span>
             <span class="c1">// NOTE:</span>
             <span class="c1">// - v2 might be null for leftOuterJoin</span>
             <span class="c1">// - v1 might be null for rightOuterJoin</span>
             <span class="c1">// - v1 OR v2 might be null for fullOuterJoin</span>
          <span class="o">}</span>
      <span class="o">});</span></code></pre></figure>

      </td>
    </tr>

    <tr>
      <td><strong>CoGroup</strong></td>
      <td>
        <p>对两维数据进行reduce操作， 对一个或多个字段进行分组操作，然后进行join这些分组。每一对分组都会调用该转换函数。参见 <a href="/1.1.0/apis/common/#specifying-keys">key 章节</a> 了解如何定义 join 的 key。
        </p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">data1</span><span class="o">.</span><span class="na">coGroup</span><span class="o">(</span><span class="n">data2</span><span class="o">)</span>
     <span class="o">.</span><span class="na">where</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
     <span class="o">.</span><span class="na">equalTo</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
     <span class="o">.</span><span class="na">with</span><span class="o">(</span><span class="k">new</span> <span class="n">CoGroupFunction</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">String</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;()</span> <span class="o">{</span>
         <span class="kd">public</span> <span class="kt">void</span> <span class="nf">coGroup</span><span class="o">(</span><span class="n">Iterable</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">in1</span><span class="o">,</span> <span class="n">Iterable</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">in2</span><span class="o">,</span> <span class="n">Collector</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">out</span><span class="o">)</span> <span class="o">{</span>
           <span class="n">out</span><span class="o">.</span><span class="na">collect</span><span class="o">(...);</span>
         <span class="o">}</span>
      <span class="o">});</span></code></pre></figure>

      </td>
    </tr>

    <tr>
      <td><strong>Cross</strong></td>
      <td>
        <p>对两个输入进行笛卡尔积（cross product），生成所有的元素对。可选地，可以使用 CrossFunction 将元素对转换成单个元素。
        </p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">DataSet</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">data1</span> <span class="o">=</span> <span class="c1">// [...]</span>
<span class="n">DataSet</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">data2</span> <span class="o">=</span> <span class="c1">// [...]</span>
<span class="n">DataSet</span><span class="o">&lt;</span><span class="n">Tuple2</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">data1</span><span class="o">.</span><span class="na">cross</span><span class="o">(</span><span class="n">data2</span><span class="o">);</span></code></pre></figure>

      <p>注意：Cross 是一个潜在的计算量非常大的操作。建议通过使用 <i>crossWithTiny()</i> 和 <i>crossWithHuge()</i> 告诉系统该数据集的大小。
      </p>
      </td>
    </tr>
    <tr>
      <td><strong>Union</strong></td>
      <td>
        <p>生成两个数据集的并集。如果多于一个数据集被用作函数的输入，该操作会被隐式地调用。
        </p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">DataSet</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">data1</span> <span class="o">=</span> <span class="c1">// [...]</span>
<span class="n">DataSet</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">data2</span> <span class="o">=</span> <span class="c1">// [...]</span>
<span class="n">DataSet</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">data1</span><span class="o">.</span><span class="na">union</span><span class="o">(</span><span class="n">data2</span><span class="o">);</span></code></pre></figure>

      </td>
    </tr>
    <tr>
      <td><strong>Rebalance</strong></td>
      <td>
        <p>
        主要是解决在多分区情况下，数据倾斜问题。将一个数据集均匀地分布到多个并行分区中。只有类似 map 的转换操作会跟在 rebalance 转换之后。</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">DataSet</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">in</span> <span class="o">=</span> <span class="c1">// [...]</span>
<span class="n">DataSet</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">in</span><span class="o">.</span><span class="na">rebalance</span><span class="o">()</span>
                           <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="k">new</span> <span class="nf">Mapper</span><span class="o">());</span></code></pre></figure>

      </td>
    </tr>
    <tr>
      <td><strong>Hash-Partition</strong></td>
      <td>
        <p>在某个key上执行哈希分区。Key 可以是 position key，也可以是 expression key，或是 selector 函数。
        </p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">DataSet</span><span class="o">&lt;</span><span class="n">Tuple2</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span><span class="n">Integer</span><span class="o">&gt;&gt;</span> <span class="n">in</span> <span class="o">=</span> <span class="c1">// [...]</span>
<span class="n">DataSet</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">in</span><span class="o">.</span><span class="na">partitionByHash</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
                            <span class="o">.</span><span class="na">mapPartition</span><span class="o">(</span><span class="k">new</span> <span class="nf">PartitionMapper</span><span class="o">());</span></code></pre></figure>

      </td>
    </tr>
    <tr>
      <td><strong>Range-Partition</strong></td>
      <td>
        <p>在某个key上 Range-Partition。Key 可以是 position key，也可以是 expression key，或是 selector 函数。
        </p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">DataSet</span><span class="o">&lt;</span><span class="n">Tuple2</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span><span class="n">Integer</span><span class="o">&gt;&gt;</span> <span class="n">in</span> <span class="o">=</span> <span class="c1">// [...]</span>
<span class="n">DataSet</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">in</span><span class="o">.</span><span class="na">partitionByRange</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
                            <span class="o">.</span><span class="na">mapPartition</span><span class="o">(</span><span class="k">new</span> <span class="nf">PartitionMapper</span><span class="o">());</span></code></pre></figure>

      </td>
    </tr>
    <tr>
      <td><strong>Custom Partitioning</strong></td>
      <td>
        <p>自定义分区操作。在数据上手工指定一个分区函数。
          <br />
          <i>注意</i>: 该方法仅在单字段 key 上有效。</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">DataSet</span><span class="o">&lt;</span><span class="n">Tuple2</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span><span class="n">Integer</span><span class="o">&gt;&gt;</span> <span class="n">in</span> <span class="o">=</span> <span class="c1">// [...]</span>
<span class="n">DataSet</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">in</span><span class="o">.</span><span class="na">partitionCustom</span><span class="o">(</span><span class="n">Partitioner</span><span class="o">&lt;</span><span class="n">K</span><span class="o">&gt;</span> <span class="n">partitioner</span><span class="o">,</span> <span class="n">key</span><span class="o">)</span></code></pre></figure>

      </td>
    </tr>
    <tr>
      <td><strong>Sort Partition</strong></td>
      <td>
        <p>在某个字段上本地排序所有分区的数据。字段可以指定为 tuple 下标，或字段表达式。
        在多字段上排序可以通过 chaining 上 sortPartition()。
         </p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">DataSet</span><span class="o">&lt;</span><span class="n">Tuple2</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span><span class="n">Integer</span><span class="o">&gt;&gt;</span> <span class="n">in</span> <span class="o">=</span> <span class="c1">// [...]</span>
<span class="n">DataSet</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">in</span><span class="o">.</span><span class="na">sortPartition</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">Order</span><span class="o">.</span><span class="na">ASCENDING</span><span class="o">)</span>
                            <span class="o">.</span><span class="na">mapPartition</span><span class="o">(</span><span class="k">new</span> <span class="nf">PartitionMapper</span><span class="o">());</span></code></pre></figure>

      </td>
    </tr>
    <tr>
      <td><strong>First-n</strong></td>
      <td>
        <p>返回一个数据集中的的前 n（任意）个元素。First-n 可以应用在普通的数据集上，或是分组的数据集上，或是分组且排序的数据集上。分组的 key 可以指定为 key-selector 函数，或是 field position。
         </p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">DataSet</span><span class="o">&lt;</span><span class="n">Tuple2</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span><span class="n">Integer</span><span class="o">&gt;&gt;</span> <span class="n">in</span> <span class="o">=</span> <span class="c1">// [...]</span>
<span class="c1">// regular data set</span>
<span class="n">DataSet</span><span class="o">&lt;</span><span class="n">Tuple2</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span><span class="n">Integer</span><span class="o">&gt;&gt;</span> <span class="n">result1</span> <span class="o">=</span> <span class="n">in</span><span class="o">.</span><span class="na">first</span><span class="o">(</span><span class="mi">3</span><span class="o">);</span>
<span class="c1">// grouped data set</span>
<span class="n">DataSet</span><span class="o">&lt;</span><span class="n">Tuple2</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span><span class="n">Integer</span><span class="o">&gt;&gt;</span> <span class="n">result2</span> <span class="o">=</span> <span class="n">in</span><span class="o">.</span><span class="na">groupBy</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
                                            <span class="o">.</span><span class="na">first</span><span class="o">(</span><span class="mi">3</span><span class="o">);</span>
<span class="c1">// grouped-sorted data set</span>
<span class="n">DataSet</span><span class="o">&lt;</span><span class="n">Tuple2</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span><span class="n">Integer</span><span class="o">&gt;&gt;</span> <span class="n">result3</span> <span class="o">=</span> <span class="n">in</span><span class="o">.</span><span class="na">groupBy</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
                                            <span class="o">.</span><span class="na">sortGroup</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">Order</span><span class="o">.</span><span class="na">ASCENDING</span><span class="o">)</span>
                                            <span class="o">.</span><span class="na">first</span><span class="o">(</span><span class="mi">3</span><span class="o">);</span></code></pre></figure>

      </td>
    </tr>
  </tbody>
</table>

    <hr />

    <p>以下的转换操作仅可以用在 Tuple 的数据集上：</p>

    <table class="table table-bordered">
  <thead>
    <tr>
      <th class="text-left" style="width: 20%">转换</th>
      <th class="text-center">描述</th>
    </tr>
  </thead>
  <tbody>
   <tr>
      <td><strong>Project</strong></td>
      <td>
        <p>从 tuples 中选择一部分字段子集。
        </p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">DataSet</span><span class="o">&lt;</span><span class="n">Tuple3</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">Double</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;&gt;</span> <span class="n">in</span> <span class="o">=</span> <span class="c1">// [...]</span>
<span class="n">DataSet</span><span class="o">&lt;</span><span class="n">Tuple2</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;&gt;</span> <span class="n">out</span> <span class="o">=</span> <span class="n">in</span><span class="o">.</span><span class="na">project</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span><span class="mi">0</span><span class="o">);</span></code></pre></figure>

      </td>
    </tr>
  </tbody>
</table>

  </div>
  <div data-lang="scala">
    <p><br /></p>

    <table class="table table-bordered">
  <thead>
    <tr>
      <th class="text-left" style="width: 20%">Transformation</th>
      <th class="text-center">Description</th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td><strong>Map</strong></td>
      <td>
        <p>输入一个元素，生成一个元素。</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="n">data</span><span class="o">.</span><span class="n">map</span> <span class="o">{</span> <span class="n">x</span> <span class="k">=&gt;</span> <span class="n">x</span><span class="o">.</span><span class="n">toInt</span> <span class="o">}</span></code></pre></figure>

      </td>
    </tr>

    <tr>
      <td><strong>FlatMap</strong></td>
      <td>
        <p>输入一个元素，生成零个、一个、或多个元素。</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="n">data</span><span class="o">.</span><span class="n">flatMap</span> <span class="o">{</span> <span class="n">str</span> <span class="k">=&gt;</span> <span class="n">str</span><span class="o">.</span><span class="n">split</span><span class="o">(</span><span class="s">&quot; &quot;</span><span class="o">)</span> <span class="o">}</span></code></pre></figure>

      </td>
    </tr>

    <tr>
      <td><strong>MapPartition</strong></td>
      <td>
        <p>在一个函数中对一个并行的分区进行转换。该函数将分区以 <code>Iterable</code> 流的形式传入，然后生成任意数量的结果值。每个分区中的元素数量取决于上一个操作的并行度。</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="n">data</span><span class="o">.</span><span class="n">mapPartition</span> <span class="o">{</span> <span class="n">in</span> <span class="k">=&gt;</span> <span class="n">in</span> <span class="n">map</span> <span class="o">{</span> <span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span> <span class="o">}</span> <span class="o">}</span></code></pre></figure>

      </td>
    </tr>

    <tr>
      <td><strong>Filter</strong></td>
      <td>
        <p>执行过滤操作，对每个元素进行判断，只保留函数返回为 true 的元素。
          <strong>重要:</strong> 系统假定该方法不会修改元素。违反该假定的话可能会导致错误的结果。
        </p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="n">data</span><span class="o">.</span><span class="n">filter</span> <span class="o">{</span> <span class="k">_</span> <span class="o">&gt;</span> <span class="mi">1000</span> <span class="o">}</span></code></pre></figure>

      </td>
    </tr>

    <tr>
      <td><strong>Reduce</strong></td>
      <td>
        <p>通过不断重复合并两个元素到一个元素的操作，将一组元素合并为一个元素。Reduce 可以应用在一个完整的数据集上，或者已分组的数据集上。</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="n">data</span><span class="o">.</span><span class="n">reduce</span> <span class="o">{</span> <span class="k">_</span> <span class="o">+</span> <span class="k">_</span> <span class="o">}</span></code></pre></figure>

      </td>
    </tr>

    <tr>
      <td><strong>ReduceGroup</strong></td>
      <td>
        <p>将一组元素合并为一个或多个元素。ReduceGroup 可以应用在一个完整的数据集上，或者已分组的数据集上。</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="n">data</span><span class="o">.</span><span class="n">reduceGroup</span> <span class="o">{</span> <span class="n">elements</span> <span class="k">=&gt;</span> <span class="n">elements</span><span class="o">.</span><span class="n">sum</span> <span class="o">}</span></code></pre></figure>

      </td>
    </tr>

    <tr>
      <td><strong>Aggregate</strong></td>
      <td>
        <p>将一组值聚合到一个值中。Aggregation 函数可以认为是内建的 reduce 函数。Aggregate 可以应用在一个完整的数据集上，或者已分组的数据集上。</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">input</span><span class="k">:</span> <span class="kt">DataSet</span><span class="o">[(</span><span class="kt">Int</span>, <span class="kt">String</span>, <span class="kt">Double</span><span class="o">)]</span> <span class="k">=</span> <span class="c1">// [...]</span>
<span class="k">val</span> <span class="n">output</span><span class="k">:</span> <span class="kt">DataSet</span><span class="o">[(</span><span class="kt">Int</span>, <span class="kt">String</span>, <span class="kt">Doublr</span><span class="o">)]</span> <span class="k">=</span> <span class="n">input</span><span class="o">.</span><span class="n">aggregate</span><span class="o">(</span><span class="nc">SUM</span><span class="o">,</span> <span class="mi">0</span><span class="o">).</span><span class="n">aggregate</span><span class="o">(</span><span class="nc">MIN</span><span class="o">,</span> <span class="mi">2</span><span class="o">);</span></code></pre></figure>

  <p>同时，对于 minimum, maximum, 和 sum 聚合，你也可以使用简写语法。</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">input</span><span class="k">:</span> <span class="kt">DataSet</span><span class="o">[(</span><span class="kt">Int</span>, <span class="kt">String</span>, <span class="kt">Double</span><span class="o">)]</span> <span class="k">=</span> <span class="c1">// [...]</span>
<span class="k">val</span> <span class="n">output</span><span class="k">:</span> <span class="kt">DataSet</span><span class="o">[(</span><span class="kt">Int</span>, <span class="kt">String</span>, <span class="kt">Doublr</span><span class="o">)]</span> <span class="k">=</span> <span class="n">input</span><span class="o">.</span><span class="n">sum</span><span class="o">(</span><span class="mi">0</span><span class="o">).</span><span class="n">min</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span></code></pre></figure>

      </td>
    </tr>

    <tr>
      <td><strong>Distinct</strong></td>
      <td>
        <p>返回数据集中不重复的元素。去除了输入数据集中在全字段（或字段子集）上重复的元素。</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala">   <span class="n">data</span><span class="o">.</span><span class="n">distinct</span><span class="o">()</span></code></pre></figure>

      </td>
    </tr>

    &lt;/tr&gt;
      <td><strong>Join</strong></td>
      <td>
      Join 两个数据集，生成所有 key 相同的元素对。 可选地，可以使用 JoinFunction 转换元素对为单个元素，或者使用 FlatJoinFunction 转换元素对为任意多（包括无）的元素。参见 <a href="/1.1.0/apis/common/#specifying-keys">key 章节</a> 了解如何定义 join 的 key。

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="c1">// In this case tuple fields are used as keys. &quot;0&quot; is the join field on the first tuple</span>
<span class="c1">// &quot;1&quot; is the join field on the second tuple.</span>
<span class="k">val</span> <span class="n">result</span> <span class="k">=</span> <span class="n">input1</span><span class="o">.</span><span class="n">join</span><span class="o">(</span><span class="n">input2</span><span class="o">).</span><span class="n">where</span><span class="o">(</span><span class="mi">0</span><span class="o">).</span><span class="n">equalTo</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span></code></pre></figure>

  你可以通过 <i>Join Hints</i> 指定 join 执行的方式。Hint 描述了 join 是否会有分区或广播的发生，以及是否使用了基于排序或基于哈希的算法。请参考 <a href="dataset_transformations.html#join-algorithm-hints">转换指南</a> 了解可用的 hint 列表以及示例。 <br />
  如果没有指定 hint，系统会尝试对输入数据进行估算并根据估算结果选择一个最佳策略。

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="c1">// This executes a join by broadcasting the first data set</span>
<span class="c1">// using a hash table for the broadcasted data</span>
<span class="k">val</span> <span class="n">result</span> <span class="k">=</span> <span class="n">input1</span><span class="o">.</span><span class="n">join</span><span class="o">(</span><span class="n">input2</span><span class="o">,</span> <span class="nc">JoinHint</span><span class="o">.</span><span class="nc">BROADCAST_HASH_FIRST</span><span class="o">)</span>
                   <span class="o">.</span><span class="n">where</span><span class="o">(</span><span class="mi">0</span><span class="o">).</span><span class="n">equalTo</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span></code></pre></figure>

          Note that the join transformation works only for equi-joins. Other join types need to be expressed using OuterJoin or CoGroup.
      </td>
    &lt;/tr&gt;

    <tr>
      <td><strong>OuterJoin</strong></td>
      <td>
      在两个数据集上执行 left/right/full-outer join。Outer join 类似普通的（inner）join，会生成相同 key 的所有元素对。额外的，对于 "outer" （left 或 right 或 full）那一面的记录而言，如果在另一面没有找到匹配的 key，则这些记录都会被保留。匹配的元素对（或一个元素和另一边的一个 null 值）传入到 JoinFunction 中被转成了单个的元素，或传入到 FlatJoinFunction 中被转成了任意多（包括无）的元素。参见 <a href="/1.1.0/apis/common/#specifying-keys">key 章节</a> 了解如何定义 join 的 key。

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">joined</span> <span class="k">=</span> <span class="n">left</span><span class="o">.</span><span class="n">leftOuterJoin</span><span class="o">(</span><span class="n">right</span><span class="o">).</span><span class="n">where</span><span class="o">(</span><span class="mi">0</span><span class="o">).</span><span class="n">equalTo</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
   <span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">)</span> <span class="k">=&gt;</span>
     <span class="k">val</span> <span class="n">a</span> <span class="k">=</span> <span class="k">if</span> <span class="o">(</span><span class="n">left</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="s">&quot;none&quot;</span> <span class="k">else</span> <span class="n">left</span><span class="o">.</span><span class="n">_1</span>
     <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">right</span><span class="o">)</span>
  <span class="o">}</span></code></pre></figure>

      </td>
    </tr>

    <tr>
      <td><strong>CoGroup</strong></td>
      <td>
        <p>对两维数据进行reduce操作， 对一个或多个字段进行分组操作，然后进行join这些分组。每一对分组都会调用该转换函数。参见 <a href="/1.1.0/apis/common/#specifying-keys">key 章节</a> 了解如何定义 join 的 key。</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="n">data1</span><span class="o">.</span><span class="n">coGroup</span><span class="o">(</span><span class="n">data2</span><span class="o">).</span><span class="n">where</span><span class="o">(</span><span class="mi">0</span><span class="o">).</span><span class="n">equalTo</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span></code></pre></figure>

      </td>
    </tr>

    <tr>
      <td><strong>Cross</strong></td>
      <td>
        <p>对两个输入进行笛卡尔积（cross product），生成所有的元素对。可选地，可以使用 CrossFunction 将元素对转换成单个元素。</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">data1</span><span class="k">:</span> <span class="kt">DataSet</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="c1">// [...]</span>
<span class="k">val</span> <span class="n">data2</span><span class="k">:</span> <span class="kt">DataSet</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="c1">// [...]</span>
<span class="k">val</span> <span class="n">result</span><span class="k">:</span> <span class="kt">DataSet</span><span class="o">[(</span><span class="kt">Int</span>, <span class="kt">String</span><span class="o">)]</span> <span class="k">=</span> <span class="n">data1</span><span class="o">.</span><span class="n">cross</span><span class="o">(</span><span class="n">data2</span><span class="o">)</span></code></pre></figure>

  <p>注意：Cross 是一个潜在的计算量非常大的操作。建议通过使用 <i>crossWithTiny()</i> 和 <i>crossWithHuge()</i> 告诉系统该数据集的大小。</p>
      </td>
    </tr>
    <tr>
      <td><strong>Union</strong></td>
      <td>
        <p>生成两个数据集的并集。如果多于一个数据集被用作函数的输入，该操作会被隐式地调用。</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="n">data</span><span class="o">.</span><span class="n">union</span><span class="o">(</span><span class="n">data2</span><span class="o">)</span></code></pre></figure>

      </td>
    </tr>
    <tr>
      <td><strong>Rebalance</strong></td>
      <td>
        <p>主要是解决在多分区情况下，数据倾斜问题。将一个数据集均匀地分布到多个并行分区中。只有类似 map 的转换操作会跟在 rebalance 转换之后。</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">data1</span><span class="k">:</span> <span class="kt">DataSet</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="c1">// [...]</span>
<span class="k">val</span> <span class="n">result</span><span class="k">:</span> <span class="kt">DataSet</span><span class="o">[(</span><span class="kt">Int</span>, <span class="kt">String</span><span class="o">)]</span> <span class="k">=</span> <span class="n">data1</span><span class="o">.</span><span class="n">rebalance</span><span class="o">().</span><span class="n">map</span><span class="o">(...)</span></code></pre></figure>

      </td>
    </tr>
    <tr>
      <td><strong>Hash-Partition</strong></td>
      <td>
        <p>在某个key上执行哈希分区。Key 可以是 position key，也可以是 expression key，或是 selector 函数。</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">in</span><span class="k">:</span> <span class="kt">DataSet</span><span class="o">[(</span><span class="kt">Int</span>, <span class="kt">String</span><span class="o">)]</span> <span class="k">=</span> <span class="c1">// [...]</span>
<span class="k">val</span> <span class="n">result</span> <span class="k">=</span> <span class="n">in</span><span class="o">.</span><span class="n">partitionByHash</span><span class="o">(</span><span class="mi">0</span><span class="o">).</span><span class="n">mapPartition</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span></code></pre></figure>

      </td>
    </tr>
    <tr>
      <td><strong>Range-Partition</strong></td>
      <td>
        <p>在某个key上 Range-Partition。Key 可以是 position key，也可以是 expression key，或是 selector 函数。</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">in</span><span class="k">:</span> <span class="kt">DataSet</span><span class="o">[(</span><span class="kt">Int</span>, <span class="kt">String</span><span class="o">)]</span> <span class="k">=</span> <span class="c1">// [...]</span>
<span class="k">val</span> <span class="n">result</span> <span class="k">=</span> <span class="n">in</span><span class="o">.</span><span class="n">partitionByRange</span><span class="o">(</span><span class="mi">0</span><span class="o">).</span><span class="n">mapPartition</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span></code></pre></figure>

      </td>
    </tr>
    &lt;/tr&gt;
    <tr>
      <td><strong>Custom Partitioning</strong></td>
      <td>
        <p>自定义分区操作。在数据上手工指定一个分区函数。 
          <br />
          <i>注意</i>: 该方法仅在单字段 key 上有效。</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">in</span><span class="k">:</span> <span class="kt">DataSet</span><span class="o">[(</span><span class="kt">Int</span>, <span class="kt">String</span><span class="o">)]</span> <span class="k">=</span> <span class="c1">// [...]</span>
<span class="k">val</span> <span class="n">result</span> <span class="k">=</span> <span class="n">in</span>
  <span class="o">.</span><span class="n">partitionCustom</span><span class="o">(</span><span class="n">partitioner</span><span class="k">:</span> <span class="kt">Partitioner</span><span class="o">[</span><span class="kt">K</span><span class="o">],</span> <span class="n">key</span><span class="o">)</span></code></pre></figure>

      </td>
    </tr>
    <tr>
      <td><strong>Sort Partition</strong></td>
      <td>
        <p>在某个字段上本地排序所有分区的数据。字段可以指定为 tuple 下标，或字段表达式。 在多字段上排序可以通过 chaining 上 sortPartition()。</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">in</span><span class="k">:</span> <span class="kt">DataSet</span><span class="o">[(</span><span class="kt">Int</span>, <span class="kt">String</span><span class="o">)]</span> <span class="k">=</span> <span class="c1">// [...]</span>
<span class="k">val</span> <span class="n">result</span> <span class="k">=</span> <span class="n">in</span><span class="o">.</span><span class="n">sortPartition</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="nc">Order</span><span class="o">.</span><span class="nc">ASCENDING</span><span class="o">).</span><span class="n">mapPartition</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span></code></pre></figure>

      </td>
    </tr>
    <tr>
      <td><strong>First-n</strong></td>
      <td>
        <p>返回一个数据集中的的前 n（任意）个元素。First-n 可以应用在普通的数据集上，或是分组的数据集上，或是分组且排序的数据集上。分组的 key 可以指定为 key-selector 函数，或是 field position。</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">in</span><span class="k">:</span> <span class="kt">DataSet</span><span class="o">[(</span><span class="kt">Int</span>, <span class="kt">String</span><span class="o">)]</span> <span class="k">=</span> <span class="c1">// [...]</span>
<span class="c1">// regular data set</span>
<span class="k">val</span> <span class="n">result1</span> <span class="k">=</span> <span class="n">in</span><span class="o">.</span><span class="n">first</span><span class="o">(</span><span class="mi">3</span><span class="o">)</span>
<span class="c1">// grouped data set</span>
<span class="k">val</span> <span class="n">result2</span> <span class="k">=</span> <span class="n">in</span><span class="o">.</span><span class="n">groupBy</span><span class="o">(</span><span class="mi">0</span><span class="o">).</span><span class="n">first</span><span class="o">(</span><span class="mi">3</span><span class="o">)</span>
<span class="c1">// grouped-sorted data set</span>
<span class="k">val</span> <span class="n">result3</span> <span class="k">=</span> <span class="n">in</span><span class="o">.</span><span class="n">groupBy</span><span class="o">(</span><span class="mi">0</span><span class="o">).</span><span class="n">sortGroup</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="nc">Order</span><span class="o">.</span><span class="nc">ASCENDING</span><span class="o">).</span><span class="n">first</span><span class="o">(</span><span class="mi">3</span><span class="o">)</span></code></pre></figure>

      </td>
    </tr>
  </tbody>
</table>

  </div>
</div>

<p>当对一个转换自定义一个名字时，可以通过<code>setParallelism(int)</code>来设置转换的<a href="#parallel-execution">并行度</a>, 这种方式可以帮助调试。这对于 DataSource 和 DataSinks 都是通用的。</p>

<p>传递给<code>withParameters(Configuration)</code>的 Configuration 对象，可以在用户函数内的 <code>open()</code> 函数中被访问。</p>

<p><a href="#top" class="top pull-right"><span class="glyphicon glyphicon-chevron-up"></span> Back to top</a></p>

<h2 id="data-sources">Data Sources</h2>

<div class="codetabs">
  <div data-lang="java">

    <p>Data sources 从文件或 Java 集合中创建了初始的数据集。背后的机制请参考<a href="https://github.com/apache/flink/blob/master//flink-core/src/main/java/org/apache/flink/api/common/io/InputFormat.java">InputFormat</a>。Flink 内建了多种常见格式以方便从常用文件中创建数据集。它们中的大多数都可以通过 <em>ExecutionEnvironment</em> 的函数直接使用。</p>

    <p>File-based:</p>

    <ul>
      <li>
        <p><code>readTextFile(path)</code> / <code>TextInputFormat</code> - Reads files line wise and returns them as Strings.</p>
      </li>
      <li>
        <p><code>readTextFileWithValue(path)</code> / <code>TextValueInputFormat</code> - Reads files line wise and returns them as
StringValues. StringValues are mutable strings.</p>
      </li>
      <li>
        <p><code>readCsvFile(path)</code> / <code>CsvInputFormat</code> - Parses files of comma (or another char) delimited fields.
Returns a DataSet of tuples or POJOs. Supports the basic java types and their Value counterparts as field
types.</p>
      </li>
      <li>
        <p><code>readFileOfPrimitives(path, Class)</code> / <code>PrimitiveInputFormat</code> - Parses files of new-line (or another char sequence)
delimited primitive data types such as <code>String</code> or <code>Integer</code>.</p>
      </li>
      <li>
        <p><code>readFileOfPrimitives(path, delimiter, Class)</code> / <code>PrimitiveInputFormat</code> - Parses files of new-line (or another char sequence)
 delimited primitive data types such as <code>String</code> or <code>Integer</code> using the given delimiter.</p>
      </li>
      <li>
        <p><code>readHadoopFile(FileInputFormat, Key, Value, path)</code> / <code>FileInputFormat</code> - Creates a JobConf and reads file from the specified
 path with the specified FileInputFormat, Key class and Value class and returns them as Tuple2&lt;Key, Value&gt;.</p>
      </li>
      <li>
        <p><code>readSequenceFile(Key, Value, path)</code> / <code>SequenceFileInputFormat</code> - Creates a JobConf and reads file from the specified path with
 type SequenceFileInputFormat, Key class and Value class and returns them as Tuple2&lt;Key, Value&gt;.</p>
      </li>
    </ul>

    <p>Collection-based:</p>

    <ul>
      <li>
        <p><code>fromCollection(Collection)</code> - Creates a data set from the Java Java.util.Collection. All elements
in the collection must be of the same type.</p>
      </li>
      <li>
        <p><code>fromCollection(Iterator, Class)</code> - Creates a data set from an iterator. The class specifies the
data type of the elements returned by the iterator.</p>
      </li>
      <li>
        <p><code>fromElements(T ...)</code> - Creates a data set from the given sequence of objects. All objects must be
of the same type.</p>
      </li>
      <li>
        <p><code>fromParallelCollection(SplittableIterator, Class)</code> - Creates a data set from an iterator, in
parallel. The class specifies the data type of the elements returned by the iterator.</p>
      </li>
      <li>
        <p><code>generateSequence(from, to)</code> - Generates the sequence of numbers in the given interval, in
parallel.</p>
      </li>
    </ul>

    <p>Generic:</p>

    <ul>
      <li>
        <p><code>readFile(inputFormat, path)</code> / <code>FileInputFormat</code> - Accepts a file input format.</p>
      </li>
      <li>
        <p><code>createInput(inputFormat)</code> / <code>InputFormat</code> - Accepts a generic input format.</p>
      </li>
    </ul>

    <p><strong>Examples</strong></p>

    <figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">ExecutionEnvironment</span> <span class="n">env</span> <span class="o">=</span> <span class="n">ExecutionEnvironment</span><span class="o">.</span><span class="na">getExecutionEnvironment</span><span class="o">();</span>

<span class="c1">// read text file from local files system</span>
<span class="n">DataSet</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">localLines</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="na">readTextFile</span><span class="o">(</span><span class="s">&quot;file:///path/to/my/textfile&quot;</span><span class="o">);</span>

<span class="c1">// read text file from a HDFS running at nnHost:nnPort</span>
<span class="n">DataSet</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">hdfsLines</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="na">readTextFile</span><span class="o">(</span><span class="s">&quot;hdfs://nnHost:nnPort/path/to/my/textfile&quot;</span><span class="o">);</span>

<span class="c1">// read a CSV file with three fields</span>
<span class="n">DataSet</span><span class="o">&lt;</span><span class="n">Tuple3</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">String</span><span class="o">,</span> <span class="n">Double</span><span class="o">&gt;&gt;</span> <span class="n">csvInput</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="na">readCsvFile</span><span class="o">(</span><span class="s">&quot;hdfs:///the/CSV/file&quot;</span><span class="o">)</span>
	                       <span class="o">.</span><span class="na">types</span><span class="o">(</span><span class="n">Integer</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">String</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">Double</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>

<span class="c1">// read a CSV file with five fields, taking only two of them</span>
<span class="n">DataSet</span><span class="o">&lt;</span><span class="n">Tuple2</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Double</span><span class="o">&gt;&gt;</span> <span class="n">csvInput</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="na">readCsvFile</span><span class="o">(</span><span class="s">&quot;hdfs:///the/CSV/file&quot;</span><span class="o">)</span>
                               <span class="o">.</span><span class="na">includeFields</span><span class="o">(</span><span class="s">&quot;10010&quot;</span><span class="o">)</span>  <span class="c1">// take the first and the fourth field</span>
	                       <span class="o">.</span><span class="na">types</span><span class="o">(</span><span class="n">String</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">Double</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>

<span class="c1">// read a CSV file with three fields into a POJO (Person.class) with corresponding fields</span>
<span class="n">DataSet</span><span class="o">&lt;</span><span class="n">Person</span><span class="o">&gt;&gt;</span> <span class="n">csvInput</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="na">readCsvFile</span><span class="o">(</span><span class="s">&quot;hdfs:///the/CSV/file&quot;</span><span class="o">)</span>
                         <span class="o">.</span><span class="na">pojoType</span><span class="o">(</span><span class="n">Person</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="s">&quot;name&quot;</span><span class="o">,</span> <span class="s">&quot;age&quot;</span><span class="o">,</span> <span class="s">&quot;zipcode&quot;</span><span class="o">);</span>


<span class="c1">// read a file from the specified path of type TextInputFormat</span>
<span class="n">DataSet</span><span class="o">&lt;</span><span class="n">Tuple2</span><span class="o">&lt;</span><span class="n">LongWritable</span><span class="o">,</span> <span class="n">Text</span><span class="o">&gt;&gt;</span> <span class="n">tuples</span> <span class="o">=</span>
 <span class="n">env</span><span class="o">.</span><span class="na">readHadoopFile</span><span class="o">(</span><span class="k">new</span> <span class="nf">TextInputFormat</span><span class="o">(),</span> <span class="n">LongWritable</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">Text</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="s">&quot;hdfs://nnHost:nnPort/path/to/file&quot;</span><span class="o">);</span>

<span class="c1">// read a file from the specified path of type SequenceFileInputFormat</span>
<span class="n">DataSet</span><span class="o">&lt;</span><span class="n">Tuple2</span><span class="o">&lt;</span><span class="n">IntWritable</span><span class="o">,</span> <span class="n">Text</span><span class="o">&gt;&gt;</span> <span class="n">tuples</span> <span class="o">=</span>
 <span class="n">env</span><span class="o">.</span><span class="na">readSequenceFile</span><span class="o">(</span><span class="n">IntWritable</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">Text</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="s">&quot;hdfs://nnHost:nnPort/path/to/file&quot;</span><span class="o">);</span>

<span class="c1">// creates a set from some given elements</span>
<span class="n">DataSet</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">value</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="na">fromElements</span><span class="o">(</span><span class="s">&quot;Foo&quot;</span><span class="o">,</span> <span class="s">&quot;bar&quot;</span><span class="o">,</span> <span class="s">&quot;foobar&quot;</span><span class="o">,</span> <span class="s">&quot;fubar&quot;</span><span class="o">);</span>

<span class="c1">// generate a number sequence</span>
<span class="n">DataSet</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">&gt;</span> <span class="n">numbers</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="na">generateSequence</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">10000000</span><span class="o">);</span>

<span class="c1">// Read data from a relational database using the JDBC input format</span>
<span class="n">DataSet</span><span class="o">&lt;</span><span class="n">Tuple2</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="n">dbData</span> <span class="o">=</span>
    <span class="n">env</span><span class="o">.</span><span class="na">createInput</span><span class="o">(</span>
      <span class="c1">// create and configure input format</span>
      <span class="n">JDBCInputFormat</span><span class="o">.</span><span class="na">buildJDBCInputFormat</span><span class="o">()</span>
                     <span class="o">.</span><span class="na">setDrivername</span><span class="o">(</span><span class="s">&quot;org.apache.derby.jdbc.EmbeddedDriver&quot;</span><span class="o">)</span>
                     <span class="o">.</span><span class="na">setDBUrl</span><span class="o">(</span><span class="s">&quot;jdbc:derby:memory:persons&quot;</span><span class="o">)</span>
                     <span class="o">.</span><span class="na">setQuery</span><span class="o">(</span><span class="s">&quot;select name, age from persons&quot;</span><span class="o">)</span>
                     <span class="o">.</span><span class="na">finish</span><span class="o">(),</span>
      <span class="c1">// specify type information for DataSet</span>
      <span class="k">new</span> <span class="nf">TupleTypeInfo</span><span class="o">(</span><span class="n">Tuple2</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">STRING_TYPE_INFO</span><span class="o">,</span> <span class="n">INT_TYPE_INFO</span><span class="o">)</span>
    <span class="o">);</span>

<span class="c1">// Note: Flink&#39;s program compiler needs to infer the data types of the data items which are returned</span>
<span class="c1">// by an InputFormat. If this information cannot be automatically inferred, it is necessary to</span>
<span class="c1">// manually provide the type information as shown in the examples above.</span></code></pre></figure>

    <h4 id="configuring-csv-parsing">Configuring CSV Parsing</h4>

    <p>Flink 提供一些 CSV 解析的配置:</p>

    <ul>
      <li>
        <p><code>types(Class ... types)</code> specifies the types of the fields to parse. <strong>It is mandatory to configure the types of the parsed fields.</strong>
In case of the type class Boolean.class, “True” (case-insensitive), “False” (case-insensitive), “1” and “0” are treated as booleans.</p>
      </li>
      <li>
        <p><code>lineDelimiter(String del)</code> specifies the delimiter of individual records. The default line delimiter is the new-line character <code>'\n'</code>.</p>
      </li>
      <li>
        <p><code>fieldDelimiter(String del)</code> specifies the delimiter that separates fields of a record. The default field delimiter is the comma character <code>','</code>.</p>
      </li>
      <li>
        <p><code>includeFields(boolean ... flag)</code>, <code>includeFields(String mask)</code>, or <code>includeFields(long bitMask)</code> defines which fields to read from the input file (and which to ignore). By default the first <em>n</em> fields (as defined by the number of types in the <code>types()</code> call) are parsed.</p>
      </li>
      <li>
        <p><code>parseQuotedStrings(char quoteChar)</code> enables quoted string parsing. Strings are parsed as quoted strings if the first character of the string field is the quote character (leading or tailing whitespaces are <em>not</em> trimmed). Field delimiters within quoted strings are ignored. Quoted string parsing fails if the last character of a quoted string field is not the quote character or if the quote character appears at some point which is not the start or the end of the quoted string field (unless the quote character is escaped using ‘'). If quoted string parsing is enabled and the first character of the field is <em>not</em> the quoting string, the string is parsed as unquoted string. By default, quoted string parsing is disabled.</p>
      </li>
      <li>
        <p><code>ignoreComments(String commentPrefix)</code> specifies a comment prefix. All lines that start with the specified comment prefix are not parsed and ignored. By default, no lines are ignored.</p>
      </li>
      <li>
        <p><code>ignoreInvalidLines()</code> enables lenient parsing, i.e., lines that cannot be correctly parsed are ignored. By default, lenient parsing is disabled and invalid lines raise an exception.</p>
      </li>
      <li>
        <p><code>ignoreFirstLine()</code> configures the InputFormat to ignore the first line of the input file. By default no line is ignored.</p>
      </li>
    </ul>

    <h4 id="recursive-traversal-of-the-input-path-directory">Recursive Traversal of the Input Path Directory</h4>

    <p>遍历一个目录。对于基于文件的输入，如果输入的是一个目录，默认不会遍历子目录的文件。而是只会读取第一层目录的文件，忽略子目录的文件。可以通过设置<code>recursive.file.enumeration</code>来开启遍历子目录的设置。如下示例所示：</p>

    <figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="c1">// enable recursive enumeration of nested input files</span>
<span class="n">ExecutionEnvironment</span> <span class="n">env</span> <span class="o">=</span> <span class="n">ExecutionEnvironment</span><span class="o">.</span><span class="na">getExecutionEnvironment</span><span class="o">();</span>

<span class="c1">// create a configuration object</span>
<span class="n">Configuration</span> <span class="n">parameters</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">Configuration</span><span class="o">();</span>

<span class="c1">// set the recursive enumeration parameter</span>
<span class="n">parameters</span><span class="o">.</span><span class="na">setBoolean</span><span class="o">(</span><span class="s">&quot;recursive.file.enumeration&quot;</span><span class="o">,</span> <span class="kc">true</span><span class="o">);</span>

<span class="c1">// pass the configuration to the data source</span>
<span class="n">DataSet</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">logs</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="na">readTextFile</span><span class="o">(</span><span class="s">&quot;file:///path/with.nested/files&quot;</span><span class="o">)</span>
			  <span class="o">.</span><span class="na">withParameters</span><span class="o">(</span><span class="n">parameters</span><span class="o">);</span></code></pre></figure>

  </div>
  <div data-lang="scala">

    <p>Data sources 从文件或 Java 集合中创建了初始的数据集。背后的机制请参考<a href="https://github.com/apache/flink/blob/master//flink-core/src/main/java/org/apache/flink/api/common/io/InputFormat.java">InputFormat</a>。Flink 内建了多种常见格式以方便从常用文件中创建数据集。它们中的大多数都可以通过 <em>ExecutionEnvironment</em> 的函数直接使用。</p>

    <p>File-based:</p>

    <ul>
      <li>
        <p><code>readTextFile(path)</code> / <code>TextInputFormat</code> - Reads files line wise and returns them as Strings.</p>
      </li>
      <li>
        <p><code>readTextFileWithValue(path)</code> / <code>TextValueInputFormat</code> - Reads files line wise and returns them as
StringValues. StringValues are mutable strings.</p>
      </li>
      <li>
        <p><code>readCsvFile(path)</code> / <code>CsvInputFormat</code> - Parses files of comma (or another char) delimited fields.
Returns a DataSet of tuples, case class objects, or POJOs. Supports the basic java types and their Value counterparts as field
types.</p>
      </li>
      <li>
        <p><code>readFileOfPrimitives(path, delimiter)</code> / <code>PrimitiveInputFormat</code> - Parses files of new-line (or another char sequence)
delimited primitive data types such as <code>String</code> or <code>Integer</code> using the given delimiter.</p>
      </li>
      <li>
        <p><code>readHadoopFile(FileInputFormat, Key, Value, path)</code> / <code>FileInputFormat</code> - Creates a JobConf and reads file from the specified
 path with the specified FileInputFormat, Key class and Value class and returns them as Tuple2&lt;Key, Value&gt;.</p>
      </li>
      <li>
        <p><code>readSequenceFile(Key, Value, path)</code> / <code>SequenceFileInputFormat</code> - Creates a JobConf and reads file from the specified path with
 type SequenceFileInputFormat, Key class and Value class and returns them as Tuple2&lt;Key, Value&gt;.</p>
      </li>
    </ul>

    <p>Collection-based:</p>

    <ul>
      <li>
        <p><code>fromCollection(Seq)</code> - Creates a data set from a Seq. All elements
in the collection must be of the same type.</p>
      </li>
      <li>
        <p><code>fromCollection(Iterator)</code> - Creates a data set from an Iterator. The class specifies the
data type of the elements returned by the iterator.</p>
      </li>
      <li>
        <p><code>fromElements(elements: _*)</code> - Creates a data set from the given sequence of objects. All objects
must be of the same type.</p>
      </li>
      <li>
        <p><code>fromParallelCollection(SplittableIterator)</code> - Creates a data set from an iterator, in
parallel. The class specifies the data type of the elements returned by the iterator.</p>
      </li>
      <li>
        <p><code>generateSequence(from, to)</code> - Generates the squence of numbers in the given interval, in
parallel.</p>
      </li>
    </ul>

    <p>Generic:</p>

    <ul>
      <li>
        <p><code>readFile(inputFormat, path)</code> / <code>FileInputFormat</code> - Accepts a file input format.</p>
      </li>
      <li>
        <p><code>createInput(inputFormat)</code> / <code>InputFormat</code> - Accepts a generic input format.</p>
      </li>
    </ul>

    <p><strong>Examples</strong></p>

    <figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">env</span>  <span class="k">=</span> <span class="nc">ExecutionEnvironment</span><span class="o">.</span><span class="n">getExecutionEnvironment</span>

<span class="c1">// read text file from local files system</span>
<span class="k">val</span> <span class="n">localLines</span> <span class="k">=</span> <span class="n">env</span><span class="o">.</span><span class="n">readTextFile</span><span class="o">(</span><span class="s">&quot;file:///path/to/my/textfile&quot;</span><span class="o">)</span>

<span class="c1">// read text file from a HDFS running at nnHost:nnPort</span>
<span class="k">val</span> <span class="n">hdfsLines</span> <span class="k">=</span> <span class="n">env</span><span class="o">.</span><span class="n">readTextFile</span><span class="o">(</span><span class="s">&quot;hdfs://nnHost:nnPort/path/to/my/textfile&quot;</span><span class="o">)</span>

<span class="c1">// read a CSV file with three fields</span>
<span class="k">val</span> <span class="n">csvInput</span> <span class="k">=</span> <span class="n">env</span><span class="o">.</span><span class="n">readCsvFile</span><span class="o">[(</span><span class="kt">Int</span>, <span class="kt">String</span>, <span class="kt">Double</span><span class="o">)](</span><span class="s">&quot;hdfs:///the/CSV/file&quot;</span><span class="o">)</span>

<span class="c1">// read a CSV file with five fields, taking only two of them</span>
<span class="k">val</span> <span class="n">csvInput</span> <span class="k">=</span> <span class="n">env</span><span class="o">.</span><span class="n">readCsvFile</span><span class="o">[(</span><span class="kt">String</span>, <span class="kt">Double</span><span class="o">)](</span>
  <span class="s">&quot;hdfs:///the/CSV/file&quot;</span><span class="o">,</span>
  <span class="n">includedFields</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">3</span><span class="o">))</span> <span class="c1">// take the first and the fourth field</span>

<span class="c1">// CSV input can also be used with Case Classes</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">MyCaseClass</span><span class="o">(</span><span class="n">str</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">dbl</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span>
<span class="k">val</span> <span class="n">csvInput</span> <span class="k">=</span> <span class="n">env</span><span class="o">.</span><span class="n">readCsvFile</span><span class="o">[</span><span class="kt">MyCaseClass</span><span class="o">](</span>
  <span class="s">&quot;hdfs:///the/CSV/file&quot;</span><span class="o">,</span>
  <span class="n">includedFields</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">3</span><span class="o">))</span> <span class="c1">// take the first and the fourth field</span>

<span class="c1">// read a CSV file with three fields into a POJO (Person) with corresponding fields</span>
<span class="k">val</span> <span class="n">csvInput</span> <span class="k">=</span> <span class="n">env</span><span class="o">.</span><span class="n">readCsvFile</span><span class="o">[</span><span class="kt">Person</span><span class="o">](</span>
  <span class="s">&quot;hdfs:///the/CSV/file&quot;</span><span class="o">,</span>
  <span class="n">pojoFields</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="s">&quot;name&quot;</span><span class="o">,</span> <span class="s">&quot;age&quot;</span><span class="o">,</span> <span class="s">&quot;zipcode&quot;</span><span class="o">))</span>

<span class="c1">// create a set from some given elements</span>
<span class="k">val</span> <span class="n">values</span> <span class="k">=</span> <span class="n">env</span><span class="o">.</span><span class="n">fromElements</span><span class="o">(</span><span class="s">&quot;Foo&quot;</span><span class="o">,</span> <span class="s">&quot;bar&quot;</span><span class="o">,</span> <span class="s">&quot;foobar&quot;</span><span class="o">,</span> <span class="s">&quot;fubar&quot;</span><span class="o">)</span>

<span class="c1">// generate a number sequence</span>
<span class="k">val</span> <span class="n">numbers</span> <span class="k">=</span> <span class="n">env</span><span class="o">.</span><span class="n">generateSequence</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">10000000</span><span class="o">);</span>

<span class="c1">// read a file from the specified path of type TextInputFormat</span>
<span class="k">val</span> <span class="n">tuples</span> <span class="k">=</span> <span class="n">env</span><span class="o">.</span><span class="n">readHadoopFile</span><span class="o">(</span><span class="k">new</span> <span class="nc">TextInputFormat</span><span class="o">,</span> <span class="n">classOf</span><span class="o">[</span><span class="kt">LongWritable</span><span class="o">],</span>
 <span class="n">classOf</span><span class="o">[</span><span class="kt">Text</span><span class="o">],</span> <span class="s">&quot;hdfs://nnHost:nnPort/path/to/file&quot;</span><span class="o">)</span>

<span class="c1">// read a file from the specified path of type SequenceFileInputFormat</span>
<span class="k">val</span> <span class="n">tuples</span> <span class="k">=</span> <span class="n">env</span><span class="o">.</span><span class="n">readSequenceFile</span><span class="o">(</span><span class="n">classOf</span><span class="o">[</span><span class="kt">IntWritable</span><span class="o">],</span> <span class="n">classOf</span><span class="o">[</span><span class="kt">Text</span><span class="o">],</span>
 <span class="s">&quot;hdfs://nnHost:nnPort/path/to/file&quot;</span><span class="o">)</span></code></pre></figure>

    <h4 id="configuring-csv-parsing-1">Configuring CSV Parsing</h4>

    <p>Flink 提供一些 CSV 解析的配置参数：</p>

    <ul>
      <li>
        <p><code>lineDelimiter: String</code> specifies the delimiter of individual records. The default line delimiter is the new-line character <code>'\n'</code>.</p>
      </li>
      <li>
        <p><code>fieldDelimiter: String</code> specifies the delimiter that separates fields of a record. The default field delimiter is the comma character <code>','</code>.</p>
      </li>
      <li>
        <p><code>includeFields: Array[Int]</code> defines which fields to read from the input file (and which to ignore). By default the first <em>n</em> fields (as defined by the number of types in the <code>types()</code> call) are parsed.</p>
      </li>
      <li>
        <p><code>pojoFields: Array[String]</code> specifies the fields of a POJO that are mapped to CSV fields. Parsers for CSV fields are automatically initialized based on the type and order of the POJO fields.</p>
      </li>
      <li>
        <p><code>parseQuotedStrings: Character</code> enables quoted string parsing. Strings are parsed as quoted strings if the first character of the string field is the quote character (leading or tailing whitespaces are <em>not</em> trimmed). Field delimiters within quoted strings are ignored. Quoted string parsing fails if the last character of a quoted string field is not the quote character. If quoted string parsing is enabled and the first character of the field is <em>not</em> the quoting string, the string is parsed as unquoted string. By default, quoted string parsing is disabled.</p>
      </li>
      <li>
        <p><code>ignoreComments: String</code> specifies a comment prefix. All lines that start with the specified comment prefix are not parsed and ignored. By default, no lines are ignored.</p>
      </li>
      <li>
        <p><code>lenient: Boolean</code> enables lenient parsing, i.e., lines that cannot be correctly parsed are ignored. By default, lenient parsing is disabled and invalid lines raise an exception.</p>
      </li>
      <li>
        <p><code>ignoreFirstLine: Boolean</code> configures the InputFormat to ignore the first line of the input file. By default no line is ignored.</p>
      </li>
    </ul>

    <h4 id="recursive-traversal-of-the-input-path-directory-1">Recursive Traversal of the Input Path Directory</h4>

    <p>遍历一个目录。对于基于文件的输入，如果输入的是一个目录，默认不会遍历子目录的文件。而是只会读取第一层目录的文件，忽略子目录的文件。可以通过设置<code>recursive.file.enumeration</code>来开启遍历子目录的设置。如下示例所示：</p>

    <figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="c1">// enable recursive enumeration of nested input files</span>
<span class="k">val</span> <span class="n">env</span>  <span class="k">=</span> <span class="nc">ExecutionEnvironment</span><span class="o">.</span><span class="n">getExecutionEnvironment</span>

<span class="c1">// create a configuration object</span>
<span class="k">val</span> <span class="n">parameters</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Configuration</span>

<span class="c1">// set the recursive enumeration parameter</span>
<span class="n">parameters</span><span class="o">.</span><span class="n">setBoolean</span><span class="o">(</span><span class="s">&quot;recursive.file.enumeration&quot;</span><span class="o">,</span> <span class="kc">true</span><span class="o">)</span>

<span class="c1">// pass the configuration to the data source</span>
<span class="n">env</span><span class="o">.</span><span class="n">readTextFile</span><span class="o">(</span><span class="s">&quot;file:///path/with.nested/files&quot;</span><span class="o">).</span><span class="n">withParameters</span><span class="o">(</span><span class="n">parameters</span><span class="o">)</span></code></pre></figure>

  </div>
</div>

<h3 id="read-compressed-files">Read Compressed Files</h3>

<p>Flink 对于一些扩展名确定的压缩文件能自动解压。也就是说不需要配置 input format 和 <code>FileInputFormat</code>来做压缩。注意，并不能并行来读取压缩文件，这样会影响scalability。</p>

<table class="table table-bordered">
  <thead>
    <tr>
      <th class="text-left" style="width: 20%">压缩方法</th>
      <th class="text-left">文件后缀</th>
      <th class="text-left" style="width: 20%">可并行化</th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td><strong>DEFLATE</strong></td>
      <td>`.deflate`</td>
      <td>no</td>
    </tr>
    <tr>
      <td><strong>GZip</strong></td>
      <td>`.gz`, `.gzip`</td>
      <td>no</td>
    </tr>
  </tbody>
</table>

<p><a href="#top" class="top pull-right"><span class="glyphicon glyphicon-chevron-up"></span> Back to top</a></p>

<h2 id="data-sinks">Data Sinks</h2>

<div class="codetabs">
  <div data-lang="java">

    <p>Data sinks 消费 DataSets，用来存储或返回它们。Data sink 的操作可以用<a href="https://github.com/apache/flink/blob/master//flink-core/src/main/java/org/apache/flink/api/common/io/OutputFormat.java">OutputFormat</a>来描述。Flink 在 DataSet 中内建了一些 output format：</p>

    <ul>
      <li><code>writeAsText()</code> / <code>TextOuputFormat</code> - Writes elements line-wise as Strings. The Strings are
obtained by calling the <em>toString()</em> method of each element.</li>
      <li><code>writeAsFormattedText()</code> / <code>TextOutputFormat</code> - Write elements line-wise as Strings. The Strings
are obtained by calling a user-defined <em>format()</em> method for each element.</li>
      <li><code>writeAsCsv(...)</code> / <code>CsvOutputFormat</code> - Writes tuples as comma-separated value files. Row and field
delimiters are configurable. The value for each field comes from the <em>toString()</em> method of the objects.</li>
      <li><code>print()</code> / <code>printToErr()</code> / <code>print(String msg)</code> / <code>printToErr(String msg)</code> - Prints the <em>toString()</em> value
of each element on the standard out / strandard error stream. Optionally, a prefix (msg) can be provided which is
prepended to the output. This can help to distinguish between different calls to <em>print</em>. If the parallelism is
greater than 1, the output will also be prepended with the identifier of the task which produced the output.</li>
      <li><code>write()</code> / <code>FileOutputFormat</code> - Method and base class for custom file outputs. Supports
custom object-to-bytes conversion.</li>
      <li><code>output()</code>/ <code>OutputFormat</code> - Most generic output method, for data sinks that are not file based
(such as storing the result in a database).</li>
    </ul>

    <p>一个 DataSet 可以输入到多个操作中。程序在数据集上运行其他转换的同时，还可以写或打印数据集。</p>

    <p><strong>Examples</strong></p>

    <p>标准的 data sink 函数：</p>

    <figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="c1">// text data</span>
<span class="n">DataSet</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">textData</span> <span class="o">=</span> <span class="c1">// [...]</span>

<span class="c1">// write DataSet to a file on the local file system</span>
<span class="n">textData</span><span class="o">.</span><span class="na">writeAsText</span><span class="o">(</span><span class="s">&quot;file:///my/result/on/localFS&quot;</span><span class="o">);</span>

<span class="c1">// write DataSet to a file on a HDFS with a namenode running at nnHost:nnPort</span>
<span class="n">textData</span><span class="o">.</span><span class="na">writeAsText</span><span class="o">(</span><span class="s">&quot;hdfs://nnHost:nnPort/my/result/on/localFS&quot;</span><span class="o">);</span>

<span class="c1">// write DataSet to a file and overwrite the file if it exists</span>
<span class="n">textData</span><span class="o">.</span><span class="na">writeAsText</span><span class="o">(</span><span class="s">&quot;file:///my/result/on/localFS&quot;</span><span class="o">,</span> <span class="n">WriteMode</span><span class="o">.</span><span class="na">OVERWRITE</span><span class="o">);</span>

<span class="c1">// tuples as lines with pipe as the separator &quot;a|b|c&quot;</span>
<span class="n">DataSet</span><span class="o">&lt;</span><span class="n">Tuple3</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Integer</span><span class="o">,</span> <span class="n">Double</span><span class="o">&gt;&gt;</span> <span class="n">values</span> <span class="o">=</span> <span class="c1">// [...]</span>
<span class="n">values</span><span class="o">.</span><span class="na">writeAsCsv</span><span class="o">(</span><span class="s">&quot;file:///path/to/the/result/file&quot;</span><span class="o">,</span> <span class="s">&quot;\n&quot;</span><span class="o">,</span> <span class="s">&quot;|&quot;</span><span class="o">);</span>

<span class="c1">// this writes tuples in the text formatting &quot;(a, b, c)&quot;, rather than as CSV lines</span>
<span class="n">values</span><span class="o">.</span><span class="na">writeAsText</span><span class="o">(</span><span class="s">&quot;file:///path/to/the/result/file&quot;</span><span class="o">);</span>

<span class="c1">// this wites values as strings using a user-defined TextFormatter object</span>
<span class="n">values</span><span class="o">.</span><span class="na">writeAsFormattedText</span><span class="o">(</span><span class="s">&quot;file:///path/to/the/result/file&quot;</span><span class="o">,</span>
    <span class="k">new</span> <span class="n">TextFormatter</span><span class="o">&lt;</span><span class="n">Tuple2</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;&gt;()</span> <span class="o">{</span>
        <span class="kd">public</span> <span class="n">String</span> <span class="nf">format</span> <span class="o">(</span><span class="n">Tuple2</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">value</span><span class="o">.</span><span class="na">f1</span> <span class="o">+</span> <span class="s">&quot; - &quot;</span> <span class="o">+</span> <span class="n">value</span><span class="o">.</span><span class="na">f0</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">});</span></code></pre></figure>

    <p>使用一个自定义的 output format：</p>

    <figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">DataSet</span><span class="o">&lt;</span><span class="n">Tuple3</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Integer</span><span class="o">,</span> <span class="n">Double</span><span class="o">&gt;&gt;</span> <span class="n">myResult</span> <span class="o">=</span> <span class="o">[...]</span>

<span class="c1">// write Tuple DataSet to a relational database</span>
<span class="n">myResult</span><span class="o">.</span><span class="na">output</span><span class="o">(</span>
    <span class="c1">// build and configure OutputFormat</span>
    <span class="n">JDBCOutputFormat</span><span class="o">.</span><span class="na">buildJDBCOutputFormat</span><span class="o">()</span>
                    <span class="o">.</span><span class="na">setDrivername</span><span class="o">(</span><span class="s">&quot;org.apache.derby.jdbc.EmbeddedDriver&quot;</span><span class="o">)</span>
                    <span class="o">.</span><span class="na">setDBUrl</span><span class="o">(</span><span class="s">&quot;jdbc:derby:memory:persons&quot;</span><span class="o">)</span>
                    <span class="o">.</span><span class="na">setQuery</span><span class="o">(</span><span class="s">&quot;insert into persons (name, age, height) values (?,?,?)&quot;</span><span class="o">)</span>
                    <span class="o">.</span><span class="na">finish</span><span class="o">()</span>
    <span class="o">);</span></code></pre></figure>

    <h4 id="locally-sorted-output">Locally Sorted Output</h4>

    <p>data sink 的输出可以在某些字段上基于某个顺序做本地排序，可以使用<a href="#define-keys-for-tuples">tuple field positions</a> 或 <a href="#define-keys-using-field-expressions">field expressions</a>来指定 key。这对任何 output format 都有效。</p>

    <p>下方例子展示了如何使用这一特性：</p>

    <figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">DataSet</span><span class="o">&lt;</span><span class="n">Tuple3</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">String</span><span class="o">,</span> <span class="n">Double</span><span class="o">&gt;&gt;</span> <span class="n">tData</span> <span class="o">=</span> <span class="c1">// [...]</span>
<span class="n">DataSet</span><span class="o">&lt;</span><span class="n">Tuple2</span><span class="o">&lt;</span><span class="n">BookPojo</span><span class="o">,</span> <span class="n">Double</span><span class="o">&gt;&gt;</span> <span class="n">pData</span> <span class="o">=</span> <span class="c1">// [...]</span>
<span class="n">DataSet</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">sData</span> <span class="o">=</span> <span class="c1">// [...]</span>

<span class="c1">// sort output on String field in ascending order</span>
<span class="n">tData</span><span class="o">.</span><span class="na">sortPartition</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">Order</span><span class="o">.</span><span class="na">ASCENDING</span><span class="o">).</span><span class="na">print</span><span class="o">();</span>

<span class="c1">// sort output on Double field in descending and Integer field in ascending order</span>
<span class="n">tData</span><span class="o">.</span><span class="na">sortPartition</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="n">Order</span><span class="o">.</span><span class="na">DESCENDING</span><span class="o">).</span><span class="na">sortPartition</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">Order</span><span class="o">.</span><span class="na">ASCENDING</span><span class="o">).</span><span class="na">print</span><span class="o">();</span>

<span class="c1">// sort output on the &quot;author&quot; field of nested BookPojo in descending order</span>
<span class="n">pData</span><span class="o">.</span><span class="na">sortPartition</span><span class="o">(</span><span class="s">&quot;f0.author&quot;</span><span class="o">,</span> <span class="n">Order</span><span class="o">.</span><span class="na">DESCENDING</span><span class="o">).</span><span class="na">writeAsText</span><span class="o">(...);</span>

<span class="c1">// sort output on the full tuple in ascending order</span>
<span class="n">tData</span><span class="o">.</span><span class="na">sortPartition</span><span class="o">(</span><span class="s">&quot;*&quot;</span><span class="o">,</span> <span class="n">Order</span><span class="o">.</span><span class="na">ASCENDING</span><span class="o">).</span><span class="na">writeAsCsv</span><span class="o">(...);</span>

<span class="c1">// sort atomic type (String) output in descending order</span>
<span class="n">sData</span><span class="o">.</span><span class="na">sortPartition</span><span class="o">(</span><span class="s">&quot;*&quot;</span><span class="o">,</span> <span class="n">Order</span><span class="o">.</span><span class="na">DESCENDING</span><span class="o">).</span><span class="na">writeAsText</span><span class="o">(...);</span></code></pre></figure>

    <p>目前还不支持全局的排序输出。</p>

  </div>
  <div data-lang="scala">

    <p>Data sinks 消费 DataSets，用来存储或返回它们。Data sink 的操作可以用<a href="https://github.com/apache/flink/blob/master//flink-core/src/main/java/org/apache/flink/api/common/io/OutputFormat.java">OutputFormat</a>来描述。Flink 在 DataSet 中内建了一些 output format：</p>

    <ul>
      <li><code>writeAsText()</code> / <code>TextOuputFormat</code> - Writes elements line-wise as Strings. The Strings are
obtained by calling the <em>toString()</em> method of each element.</li>
      <li><code>writeAsCsv(...)</code> / <code>CsvOutputFormat</code> - Writes tuples as comma-separated value files. Row and field
delimiters are configurable. The value for each field comes from the <em>toString()</em> method of the objects.</li>
      <li><code>print()</code> / <code>printToErr()</code> - Prints the <em>toString()</em> value of each element on the
standard out / strandard error stream.</li>
      <li><code>write()</code> / <code>FileOutputFormat</code> - Method and base class for custom file outputs. Supports
custom object-to-bytes conversion.</li>
      <li><code>output()</code>/ <code>OutputFormat</code> - Most generic output method, for data sinks that are not file based
(such as storing the result in a database).</li>
    </ul>

    <p>一个 DataSet 可以输入到多个操作中。程序在数据集上运行其他转换的同时，还可以写或打印数据集。</p>

    <p><strong>Examples</strong></p>

    <p>标准的 data sink 函数：</p>

    <figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="c1">// text data</span>
<span class="k">val</span> <span class="n">textData</span><span class="k">:</span> <span class="kt">DataSet</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="c1">// [...]</span>

<span class="c1">// write DataSet to a file on the local file system</span>
<span class="n">textData</span><span class="o">.</span><span class="n">writeAsText</span><span class="o">(</span><span class="s">&quot;file:///my/result/on/localFS&quot;</span><span class="o">)</span>

<span class="c1">// write DataSet to a file on a HDFS with a namenode running at nnHost:nnPort</span>
<span class="n">textData</span><span class="o">.</span><span class="n">writeAsText</span><span class="o">(</span><span class="s">&quot;hdfs://nnHost:nnPort/my/result/on/localFS&quot;</span><span class="o">)</span>

<span class="c1">// write DataSet to a file and overwrite the file if it exists</span>
<span class="n">textData</span><span class="o">.</span><span class="n">writeAsText</span><span class="o">(</span><span class="s">&quot;file:///my/result/on/localFS&quot;</span><span class="o">,</span> <span class="nc">WriteMode</span><span class="o">.</span><span class="nc">OVERWRITE</span><span class="o">)</span>

<span class="c1">// tuples as lines with pipe as the separator &quot;a|b|c&quot;</span>
<span class="k">val</span> <span class="n">values</span><span class="k">:</span> <span class="kt">DataSet</span><span class="o">[(</span><span class="kt">String</span>, <span class="kt">Int</span>, <span class="kt">Double</span><span class="o">)]</span> <span class="k">=</span> <span class="c1">// [...]</span>
<span class="n">values</span><span class="o">.</span><span class="n">writeAsCsv</span><span class="o">(</span><span class="s">&quot;file:///path/to/the/result/file&quot;</span><span class="o">,</span> <span class="s">&quot;\n&quot;</span><span class="o">,</span> <span class="s">&quot;|&quot;</span><span class="o">)</span>

<span class="c1">// this writes tuples in the text formatting &quot;(a, b, c)&quot;, rather than as CSV lines</span>
<span class="n">values</span><span class="o">.</span><span class="n">writeAsText</span><span class="o">(</span><span class="s">&quot;file:///path/to/the/result/file&quot;</span><span class="o">);</span>

<span class="c1">// this wites values as strings using a user-defined formatting</span>
<span class="n">values</span> <span class="n">map</span> <span class="o">{</span> <span class="n">tuple</span> <span class="k">=&gt;</span> <span class="n">tuple</span><span class="o">.</span><span class="n">_1</span> <span class="o">+</span> <span class="s">&quot; - &quot;</span> <span class="o">+</span> <span class="n">tuple</span><span class="o">.</span><span class="n">_2</span> <span class="o">}</span>
  <span class="o">.</span><span class="n">writeAsText</span><span class="o">(</span><span class="s">&quot;file:///path/to/the/result/file&quot;</span><span class="o">)</span></code></pre></figure>

    <h4 id="locally-sorted-output-1">Locally Sorted Output</h4>

    <p>data sink 的输出可以在某些字段上基于某个顺序做本地排序，可以使用<a href="#define-keys-for-tuples">tuple field positions</a> 或 <a href="#define-keys-using-field-expressions">field expressions</a>来指定 key。这对任何 output format 都有效。</p>

    <figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">tData</span><span class="k">:</span> <span class="kt">DataSet</span><span class="o">[(</span><span class="kt">Int</span>, <span class="kt">String</span>, <span class="kt">Double</span><span class="o">)]</span> <span class="k">=</span> <span class="c1">// [...]</span>
<span class="k">val</span> <span class="n">pData</span><span class="k">:</span> <span class="kt">DataSet</span><span class="o">[(</span><span class="kt">BookPojo</span>, <span class="kt">Double</span><span class="o">)]</span> <span class="k">=</span> <span class="c1">// [...]</span>
<span class="k">val</span> <span class="n">sData</span><span class="k">:</span> <span class="kt">DataSet</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="c1">// [...]</span>

<span class="c1">// sort output on String field in ascending order</span>
<span class="n">tData</span><span class="o">.</span><span class="n">sortPartition</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="nc">Order</span><span class="o">.</span><span class="nc">ASCENDING</span><span class="o">).</span><span class="n">print</span><span class="o">;</span>

<span class="c1">// sort output on Double field in descending and Int field in ascending order</span>
<span class="n">tData</span><span class="o">.</span><span class="n">sortPartition</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="nc">Order</span><span class="o">.</span><span class="nc">DESCENDING</span><span class="o">).</span><span class="n">sortPartition</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="nc">Order</span><span class="o">.</span><span class="nc">ASCENDING</span><span class="o">).</span><span class="n">print</span><span class="o">;</span>

<span class="c1">// sort output on the &quot;author&quot; field of nested BookPojo in descending order</span>
<span class="n">pData</span><span class="o">.</span><span class="n">sortPartition</span><span class="o">(</span><span class="s">&quot;_1.author&quot;</span><span class="o">,</span> <span class="nc">Order</span><span class="o">.</span><span class="nc">DESCENDING</span><span class="o">).</span><span class="n">writeAsText</span><span class="o">(...);</span>

<span class="c1">// sort output on the full tuple in ascending order</span>
<span class="n">tData</span><span class="o">.</span><span class="n">sortPartition</span><span class="o">(</span><span class="s">&quot;_&quot;</span><span class="o">,</span> <span class="nc">Order</span><span class="o">.</span><span class="nc">ASCENDING</span><span class="o">).</span><span class="n">writeAsCsv</span><span class="o">(...);</span>

<span class="c1">// sort atomic type (String) output in descending order</span>
<span class="n">sData</span><span class="o">.</span><span class="n">sortPartition</span><span class="o">(</span><span class="s">&quot;_&quot;</span><span class="o">,</span> <span class="nc">Order</span><span class="o">.</span><span class="nc">DESCENDING</span><span class="o">).</span><span class="n">writeAsText</span><span class="o">(...);</span></code></pre></figure>

    <p>目前还不支持全局的排序输出。</p>

  </div>
</div>

<p><a href="#top" class="top pull-right"><span class="glyphicon glyphicon-chevron-up"></span> Back to top</a></p>

<h2 id="iteration-operators">Iteration Operators</h2>

<p>迭代实现了 Flink 程序中的循环。迭代算子封装部分程序，并重复执行，将一次迭代的结果返回到下一次迭代中。 Flink 中有两种迭代：<strong>BulkIteration</strong> 和 <strong>DeltaIteration</strong></p>

<p>本节给出了如何快速使用这两种迭代的示例。请参见 <a href="iterations.html">迭代介绍</a> 了解更详细的说明。</p>

<div class="codetabs">
  <div data-lang="java">

    <h4 id="bulk-iterations">Bulk Iterations</h4>

    <p>可以通过 DataSet 的 <code>iterate(int)</code> 方法来创建一个 BulkIteration, 它会返回<code>IterativeDataSet</code>， 这个<code>IterativeDataSet</code> 可以用来执行常见的转换。 该方法的参数表示执行迭代的最大次数。</p>

    <p>在<code>IterativeDataSet</code>上调用<code>closeWith(DataSet)</code>来设定迭代的结束，并确定哪个转换会反馈给下一次迭代。
有一种可选方式是通过<code>closeWith(DataSet, DataSet)</code>，当该 DataSet 为空时，它会计算第二个 DataSet 并结束迭代。如果没有指定终止条件，迭代会执行给定的最大次数后再结束。</p>

    <p>下例展示了如何计算 Pi。目标是统计落在单位圆中随机点的个数。在每次迭代中，会随机算则一个随机点。如果该点落在的单位圆中，我们会增加 count。Pi 就是通过最终的 count 除上乘以 4 的迭代次数。</p>

    <figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">final</span> <span class="n">ExecutionEnvironment</span> <span class="n">env</span> <span class="o">=</span> <span class="n">ExecutionEnvironment</span><span class="o">.</span><span class="na">getExecutionEnvironment</span><span class="o">();</span>

<span class="c1">// Create initial IterativeDataSet</span>
<span class="n">IterativeDataSet</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">initial</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="na">fromElements</span><span class="o">(</span><span class="mi">0</span><span class="o">).</span><span class="na">iterate</span><span class="o">(</span><span class="mi">10000</span><span class="o">);</span>

<span class="n">DataSet</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">iteration</span> <span class="o">=</span> <span class="n">initial</span><span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="k">new</span> <span class="n">MapFunction</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;()</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">Integer</span> <span class="nf">map</span><span class="o">(</span><span class="n">Integer</span> <span class="n">i</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
        <span class="kt">double</span> <span class="n">x</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">random</span><span class="o">();</span>
        <span class="kt">double</span> <span class="n">y</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">random</span><span class="o">();</span>

        <span class="k">return</span> <span class="n">i</span> <span class="o">+</span> <span class="o">((</span><span class="n">x</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">*</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="o">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">});</span>

<span class="c1">// Iteratively transform the IterativeDataSet</span>
<span class="n">DataSet</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">count</span> <span class="o">=</span> <span class="n">initial</span><span class="o">.</span><span class="na">closeWith</span><span class="o">(</span><span class="n">iteration</span><span class="o">);</span>

<span class="n">count</span><span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="k">new</span> <span class="n">MapFunction</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">Double</span><span class="o">&gt;()</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">Double</span> <span class="nf">map</span><span class="o">(</span><span class="n">Integer</span> <span class="n">count</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">count</span> <span class="o">/</span> <span class="o">(</span><span class="kt">double</span><span class="o">)</span> <span class="mi">10000</span> <span class="o">*</span> <span class="mi">4</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}).</span><span class="na">print</span><span class="o">();</span>

<span class="n">env</span><span class="o">.</span><span class="na">execute</span><span class="o">(</span><span class="s">&quot;Iterative Pi Example&quot;</span><span class="o">);</span></code></pre></figure>

    <p>你可以查看 <a href="https://github.com/apache/flink/blob/master//flink-examples/flink-examples-batch/src/main/java/org/apache/flink/examples/java/clustering/KMeans.java">K-Means example</a>, 该示例使用了 BulkIteration 来对未标记的点进行聚类。</p>

    <h4 id="delta-iterations">Delta Iterations</h4>

    <p>Delta 迭代解决了这种场景， 每一次迭代并不是改变数据的每一点。</p>

    <p>在每一次迭代中，返回部分方案(称为workset)， delta 迭代维护跨迭代的状态(称为solution set), 这些状态通过deltas来更新。
迭代计算的结果就是最后迭代后的结果。 如果想了解delta 迭代的基本原则，请参考<a href="iterations.html">迭代介绍</a>。</p>

    <p>定义 DeltaIteration 的方式和定义 BulkIteration 很类似。对于 delta 迭代，两个数据集（workset和solution set）组成了每一次迭代的输入，新的 workset 和新的 soution set 做为每次迭代的输出。</p>

    <p>调用<code>iterateDelta(DataSet, int, int)</code> 或 <code>iterateDelta(DataSet, int, int[])</code> 来创建一个DeltaIteration。该方法需要在初始 solution set 上调用。参数分别是初始数据集，最大迭代次数和key下标。返回的<code>DeltaIteration</code>对象， 
可以通过<code>iteration.getWorkset()</code> and <code>iteration.getSolutionSet()</code> 方法来访问 workset 和 solution set。</p>

    <p>下方是 delta 迭代的一个示例：</p>

    <figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="c1">// read the initial data sets</span>
<span class="n">DataSet</span><span class="o">&lt;</span><span class="n">Tuple2</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">Double</span><span class="o">&gt;&gt;</span> <span class="n">initialSolutionSet</span> <span class="o">=</span> <span class="c1">// [...]</span>

<span class="n">DataSet</span><span class="o">&lt;</span><span class="n">Tuple2</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">Double</span><span class="o">&gt;&gt;</span> <span class="n">initialDeltaSet</span> <span class="o">=</span> <span class="c1">// [...]</span>

<span class="kt">int</span> <span class="n">maxIterations</span> <span class="o">=</span> <span class="mi">100</span><span class="o">;</span>
<span class="kt">int</span> <span class="n">keyPosition</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

<span class="n">DeltaIteration</span><span class="o">&lt;</span><span class="n">Tuple2</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">Double</span><span class="o">&gt;,</span> <span class="n">Tuple2</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">Double</span><span class="o">&gt;&gt;</span> <span class="n">iteration</span> <span class="o">=</span> <span class="n">initialSolutionSet</span>
    <span class="o">.</span><span class="na">iterateDelta</span><span class="o">(</span><span class="n">initialDeltaSet</span><span class="o">,</span> <span class="n">maxIterations</span><span class="o">,</span> <span class="n">keyPosition</span><span class="o">);</span>

<span class="n">DataSet</span><span class="o">&lt;</span><span class="n">Tuple2</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">Double</span><span class="o">&gt;&gt;</span> <span class="n">candidateUpdates</span> <span class="o">=</span> <span class="n">iteration</span><span class="o">.</span><span class="na">getWorkset</span><span class="o">()</span>
    <span class="o">.</span><span class="na">groupBy</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
    <span class="o">.</span><span class="na">reduceGroup</span><span class="o">(</span><span class="k">new</span> <span class="nf">ComputeCandidateChanges</span><span class="o">());</span>

<span class="n">DataSet</span><span class="o">&lt;</span><span class="n">Tuple2</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">Double</span><span class="o">&gt;&gt;</span> <span class="n">deltas</span> <span class="o">=</span> <span class="n">candidateUpdates</span>
    <span class="o">.</span><span class="na">join</span><span class="o">(</span><span class="n">iteration</span><span class="o">.</span><span class="na">getSolutionSet</span><span class="o">())</span>
    <span class="o">.</span><span class="na">where</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
    <span class="o">.</span><span class="na">equalTo</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
    <span class="o">.</span><span class="na">with</span><span class="o">(</span><span class="k">new</span> <span class="nf">CompareChangesToCurrent</span><span class="o">());</span>

<span class="n">DataSet</span><span class="o">&lt;</span><span class="n">Tuple2</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">Double</span><span class="o">&gt;&gt;</span> <span class="n">nextWorkset</span> <span class="o">=</span> <span class="n">deltas</span>
    <span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="k">new</span> <span class="nf">FilterByThreshold</span><span class="o">());</span>

<span class="n">iteration</span><span class="o">.</span><span class="na">closeWith</span><span class="o">(</span><span class="n">deltas</span><span class="o">,</span> <span class="n">nextWorkset</span><span class="o">)</span>
	<span class="o">.</span><span class="na">writeAsCsv</span><span class="o">(</span><span class="n">outputPath</span><span class="o">);</span></code></pre></figure>

  </div>
  <div data-lang="scala">

    <h4 id="bulk-iterations-1">Bulk Iterations</h4>

    <p>可以通过 DataSet 的 <code>iterate(int)</code> 方法来创建一个 BulkIteration, 它会返回<code>IterativeDataSet</code>， 这个<code>IterativeDataSet</code> 可以用来执行常见的转换。 该方法的参数表示执行迭代的最大次数。</p>

    <p>在<code>IterativeDataSet</code>上调用<code>closeWith(DataSet)</code>来设定迭代的结束，并确定哪个转换会反馈给下一次迭代。
有一种可选方式是通过<code>closeWith(DataSet, DataSet)</code>，当该 DataSet 为空时，它会计算第二个 DataSet 并结束迭代。如果没有指定终止条件，迭代会执行给定的最大次数后再结束。</p>

    <p>下例展示了如何计算 Pi。目标是统计落在单位圆中随机点的个数。在每次迭代中，会随机算则一个随机点。如果该点落在的单位圆中，我们会增加 count。Pi 就是通过最终的 count 除上乘以 4 的迭代次数。</p>

    <figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">env</span> <span class="k">=</span> <span class="nc">ExecutionEnvironment</span><span class="o">.</span><span class="n">getExecutionEnvironment</span><span class="o">()</span>

<span class="c1">// Create initial DataSet</span>
<span class="k">val</span> <span class="n">initial</span> <span class="k">=</span> <span class="n">env</span><span class="o">.</span><span class="n">fromElements</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>

<span class="k">val</span> <span class="n">count</span> <span class="k">=</span> <span class="n">initial</span><span class="o">.</span><span class="n">iterate</span><span class="o">(</span><span class="mi">10000</span><span class="o">)</span> <span class="o">{</span> <span class="n">iterationInput</span><span class="k">:</span> <span class="kt">DataSet</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=&gt;</span>
  <span class="k">val</span> <span class="n">result</span> <span class="k">=</span> <span class="n">iterationInput</span><span class="o">.</span><span class="n">map</span> <span class="o">{</span> <span class="n">i</span> <span class="k">=&gt;</span>
    <span class="k">val</span> <span class="n">x</span> <span class="k">=</span> <span class="nc">Math</span><span class="o">.</span><span class="n">random</span><span class="o">()</span>
    <span class="k">val</span> <span class="n">y</span> <span class="k">=</span> <span class="nc">Math</span><span class="o">.</span><span class="n">random</span><span class="o">()</span>
    <span class="n">i</span> <span class="o">+</span> <span class="o">(</span><span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">*</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="o">)</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">0</span><span class="o">)</span>
  <span class="o">}</span>
  <span class="n">result</span>
<span class="o">}</span>

<span class="k">val</span> <span class="n">result</span> <span class="k">=</span> <span class="n">count</span> <span class="n">map</span> <span class="o">{</span> <span class="n">c</span> <span class="k">=&gt;</span> <span class="n">c</span> <span class="o">/</span> <span class="mf">10000.0</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">}</span>

<span class="n">result</span><span class="o">.</span><span class="n">print</span><span class="o">()</span>

<span class="n">env</span><span class="o">.</span><span class="n">execute</span><span class="o">(</span><span class="s">&quot;Iterative Pi Example&quot;</span><span class="o">);</span></code></pre></figure>

    <p>可以checkout 
<a href="https://github.com/apache/flink/blob/master//flink-examples/flink-examples-batch/src/main/java/org/apache/flink/examples/java/clustering/KMeans.java">K-Means example</a>,
来查看更多BulkIteration操作</p>

    <h4 id="delta-iterations-1">Delta Iterations</h4>

    <p>Delta 迭代解决了这种场景：每一次迭代并不是改变数据的每一点。</p>

    <p>在每一次迭代中，返回部分方案(称为workset)， delta 迭代维护跨迭代的状态(称为solution set), 这些状态通过deltas来更新。
迭代计算的结果就是最后迭代后的结果。 如果想了解delta 迭代的基本原则，请参考<a href="iterations.html">迭代介绍</a>。</p>

    <p>定义 DeltaIteration 的方式和定义 BulkIteration 很类似。对于 delta 迭代，两个数据集（workset和solution set）组成了每一次迭代的输入，新的 workset 和新的 soution set 做为每次迭代的输出。</p>

    <p>要创建一个 DeltaIteration，需要在初始 solution set 上调用 <code>iterateDelta(initialWorkset, maxIterations, key)</code>。迭代步骤函数需要两个参数：(solutionSet, workset)，并且必须返回两个值：(solutionSetDelta, newWorkset)。</p>

    <p>下方是 delta 迭代的一个示例：</p>

    <figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="c1">// read the initial data sets</span>
<span class="k">val</span> <span class="n">initialSolutionSet</span><span class="k">:</span> <span class="kt">DataSet</span><span class="o">[(</span><span class="kt">Long</span>, <span class="kt">Double</span><span class="o">)]</span> <span class="k">=</span> <span class="c1">// [...]</span>

<span class="k">val</span> <span class="n">initialWorkset</span><span class="k">:</span> <span class="kt">DataSet</span><span class="o">[(</span><span class="kt">Long</span>, <span class="kt">Double</span><span class="o">)]</span> <span class="k">=</span> <span class="c1">// [...]</span>

<span class="k">val</span> <span class="n">maxIterations</span> <span class="k">=</span> <span class="mi">100</span>
<span class="k">val</span> <span class="n">keyPosition</span> <span class="k">=</span> <span class="mi">0</span>

<span class="k">val</span> <span class="n">result</span> <span class="k">=</span> <span class="n">initialSolutionSet</span><span class="o">.</span><span class="n">iterateDelta</span><span class="o">(</span><span class="n">initialWorkset</span><span class="o">,</span> <span class="n">maxIterations</span><span class="o">,</span> <span class="nc">Array</span><span class="o">(</span><span class="n">keyPosition</span><span class="o">))</span> <span class="o">{</span>
  <span class="o">(</span><span class="n">solution</span><span class="o">,</span> <span class="n">workset</span><span class="o">)</span> <span class="k">=&gt;</span>
    <span class="k">val</span> <span class="n">candidateUpdates</span> <span class="k">=</span> <span class="n">workset</span><span class="o">.</span><span class="n">groupBy</span><span class="o">(</span><span class="mi">1</span><span class="o">).</span><span class="n">reduceGroup</span><span class="o">(</span><span class="k">new</span> <span class="nc">ComputeCandidateChanges</span><span class="o">())</span>
    <span class="k">val</span> <span class="n">deltas</span> <span class="k">=</span> <span class="n">candidateUpdates</span><span class="o">.</span><span class="n">join</span><span class="o">(</span><span class="n">solution</span><span class="o">).</span><span class="n">where</span><span class="o">(</span><span class="mi">0</span><span class="o">).</span><span class="n">equalTo</span><span class="o">(</span><span class="mi">0</span><span class="o">)(</span><span class="k">new</span> <span class="nc">CompareChangesToCurrent</span><span class="o">())</span>

    <span class="k">val</span> <span class="n">nextWorkset</span> <span class="k">=</span> <span class="n">deltas</span><span class="o">.</span><span class="n">filter</span><span class="o">(</span><span class="k">new</span> <span class="nc">FilterByThreshold</span><span class="o">())</span>

    <span class="o">(</span><span class="n">deltas</span><span class="o">,</span> <span class="n">nextWorkset</span><span class="o">)</span>
<span class="o">}</span>

<span class="n">result</span><span class="o">.</span><span class="n">writeAsCsv</span><span class="o">(</span><span class="n">outputPath</span><span class="o">)</span>

<span class="n">env</span><span class="o">.</span><span class="n">execute</span><span class="o">()</span></code></pre></figure>

  </div>
</div>

<p><a href="#top" class="top pull-right"><span class="glyphicon glyphicon-chevron-up"></span> Back to top</a></p>

<blockquote>
  <p>注：本文剩余部分未经校验，如有问题欢迎提issue</p>
</blockquote>

<h2 id="operating-on-data-objects-in-functions">Operating on data objects in functions</h2>

<p>flink的runtime 在用户函数内以java对象的方式来交换数据。 函数从runtime从参数中接受输入数据， 返回结果作为输出。 因为在用户函数可以访问这些对象， 必须注意用户代码访问，比如
读，修改这些对象的方式。</p>

<p>用户从flink runtime接收对象，可以像普通函数参数（<code>MapFunction</code>）或通过<code>Iterable</code>参数（像<code>GroupReduceFunction</code>）。 我们称runtime传来的object为<em>input objects</em>。 
用户函数可以通过函数返回值（比如<code>MapFunction</code>）或<code>Collector</code> (像<code>FlatMapFunction</code>)来emit对象。 我们称这些emitted的对象为<em>output objects</em>.</p>

<p>flik DataSet api 设定2种模式， 它会导致runtime 创建或reuse input object的方式不同。 它同样影响了用户代码如何和输入object和输出object 交互的方式。下面章节将介绍这些
限制并展示如何实现一个安全的用户函数。</p>

<h3 id="object-reuse-disabled-default">Object-Reuse Disabled (DEFAULT)</h3>

<p>默认， flink 会禁止reuse object。 这种模式会保证在调用一个函数时，这个函数始终接收到新的对象。 这种禁止reuse方式会更安全使用。， 但会带来一定处理开销并引起更多的gc操作。</p>

<table class="table table-bordered">
  <thead>
    <tr>
      <th class="text-left" style="width: 20%">Operation</th>
      <th class="text-center">Guarantees and Restrictions</th>
    </tr>
  </thead>
  <tbody>
   <tr>
      <td><strong>Reading Input Objects</strong></td>
      <td>
        在函数内部， 它可以保证input object值不会变化。 这些包含的object 由一个iterable来提供。 举例来说， 收集iterable内的对象到一个list或map中是很安全的。注意， 这些对象可能在函数调用完被修改。所以跨函数调用时，
        记住这些历史对象是不安全的。
      </td>
   </tr>
   <tr>
      <td><strong>Modifying Input Objects</strong></td>
      <td>可以修改输入的对象</td>
   </tr>
   <tr>
      <td><strong>Emitting Input Objects</strong></td>
      <td>
        可以emit 输入的对象。 输入的对象值可能在emit后发生变化。 所以读取一个已经emitted的输入对象是不安全的。
      </td>
   </tr>
   <tr>
      <td><strong>Reading Output Objects</strong></td>
      <td>
        传给collector的对象或函数返回值有可能发生变化， 因此读取一个output 对象是不安全的。
      </td>
   </tr>
   <tr>
      <td><strong>Modifying Output Objects</strong></td>
      <td>可以modify一个emitted的对象，然后再emit一次</td>
   </tr>
  </tbody>
</table>

<p><strong>disable reuse 模式的原则:</strong></p>

<ul>
  <li>跨函数调用时， 不要remember和读取输入对象。</li>
  <li>不要在emit完对象后，再读取它。</li>
</ul>

<h3 id="object-reuse-enabled">Object-Reuse Enabled</h3>

<p>在reuse 模式下， flink runtime 最小化对象的实例化次数。 这样可以提高性能和减少gc压力。 可以通过<code>ExecutionConfig.enableObjectReuse()</code>来打开reuse模式。</p>

<table class="table table-bordered">
  <thead>
    <tr>
      <th class="text-left" style="width: 20%">Operation</th>
      <th class="text-center">Guarantees and Restrictions</th>
    </tr>
  </thead>
  <tbody>
   <tr>
      <td><strong>读取普通函数参数作为输入对象</strong></td>
      <td>
        普通函数的参数作为输入对象时， 这些对象在函数内没有被修改，但函数调用完可能被修改， 因此跨函数调用时记住这些对象是不安全的。
      </td>
   </tr>
   <tr>
      <td><strong>读取从迭代参数作为输入对象</strong></td>
      <td>
        当输入数据来自迭代器时， 输入对象仅仅当next（）函数被调用时有效。 一个iterable或iterator可能操作相同的对象很多次。 把葱iterable输入的数据放到一个list或map中是不安全的。
      </td>
   </tr>
   <tr>
      <td><strong>修改输入数据</strong></td>
      <td>千万不要修改输入的数据， 除非输入数据来自MapFunction, FlatMapFunction, MapPartitionFunction, GroupReduceFunction, GroupCombineFunction, CoGroupFunction, and InputFormat.next(reuse)</td>
   </tr>
   <tr>
      <td><strong>发送输入对象</strong></td>
      <td>
        千万不要发送输入数据，除非输入数据来自MapFunction, FlatMapFunction, MapPartitionFunction, GroupReduceFunction, GroupCombineFunction, CoGroupFunction, and InputFormat.next(reuse).</td>
      &lt;/td&gt;
   </tr>
   <tr>
      <td><strong>读取输出对象</strong></td>
      <td>
        丢给collector或作为函数结果返回的对象可能会被修改， 因此读取一个output对象是不安全的。
      </td>
   </tr>
   <tr>
      <td><strong>修改输出对象</strong></td>
      <td>用户可以修改一个output对象并再次emit</td>
   </tr>
  </tbody>
</table>

<p><strong>object reuse的原则:</strong></p>

<ul>
  <li>不要保留来自<code>Iterable</code>的输入对象.</li>
  <li>在跨函数调用时，不要保留并读取输入对象.</li>
  <li>不要修改或发送输入对象，除非输入对象来自<code>MapFunction</code>, <code>FlatMapFunction</code>, <code>MapPartitionFunction</code>, <code>GroupReduceFunction</code>, <code>GroupCombineFunction</code>, <code>CoGroupFunction</code>, and <code>InputFormat.next(reuse)</code>.</li>
  <li>为了减少对象实例化次数， 用户可以一直发送一个专用的输出对象， 并且这个对象重复被修改但从不读取.</li>
</ul>

<p><a href="#top" class="top pull-right"><span class="glyphicon glyphicon-chevron-up"></span> Back to top</a></p>

<h2 id="debugging">Debugging</h2>

<p>在分布式集群运行一个大型数据分析程序前， 最好是可以确认实现的算法能按预期的工作。 因此通常做法是，通过检查结果， debuggin和修正 不断逐步演进的过程。</p>

<p>flink 有个很好的简化开发数据分析程序的特性， 这个特性就是它制成在一个ide内本地调试程序， 注入测试程序，收集结果。</p>

<h3 id="local-execution-environment">Local Execution Environment</h3>

<p><code>LocalEnvironment</code> 会在一个单jvm 进程内启动flink系统。 如果用户是在ide里面启动LocalEnvironement， 用户就可以设置断点并轻松调试程序</p>

<div class="codetabs">
  <div data-lang="java">

    <figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">final</span> <span class="n">ExecutionEnvironment</span> <span class="n">env</span> <span class="o">=</span> <span class="n">ExecutionEnvironment</span><span class="o">.</span><span class="na">createLocalEnvironment</span><span class="o">();</span>

<span class="n">DataSet</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">lines</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="na">readTextFile</span><span class="o">(</span><span class="n">pathToTextFile</span><span class="o">);</span>
<span class="c1">// build your program</span>

<span class="n">env</span><span class="o">.</span><span class="na">execute</span><span class="o">();</span></code></pre></figure>

  </div>
  <div data-lang="scala">

    <figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">env</span> <span class="k">=</span> <span class="nc">ExecutionEnvironment</span><span class="o">.</span><span class="n">createLocalEnvironment</span><span class="o">()</span>

<span class="k">val</span> <span class="n">lines</span> <span class="k">=</span> <span class="n">env</span><span class="o">.</span><span class="n">readTextFile</span><span class="o">(</span><span class="n">pathToTextFile</span><span class="o">)</span>
<span class="c1">// build your program</span>

<span class="n">env</span><span class="o">.</span><span class="n">execute</span><span class="o">();</span></code></pre></figure>

  </div>
</div>

<h3 id="collection-data-sources-and-sinks">Collection Data Sources and Sinks</h3>

<p>通过创建输入文件并读取输出文件来提供分析程序的输入和检查结果有些笨重。 flink 可以提供一些特别的data source和data sink
，它们依赖java collection可以简化测试过程。 一旦一个程序完成测试， 它的source和sink可以很轻松被从外部存储比如hdfs上的
读取或写入 source和sink替换。</p>

<p>Collection data sources can be used as follows:</p>

<div class="codetabs">
  <div data-lang="java">

    <figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">final</span> <span class="n">ExecutionEnvironment</span> <span class="n">env</span> <span class="o">=</span> <span class="n">ExecutionEnvironment</span><span class="o">.</span><span class="na">createLocalEnvironment</span><span class="o">();</span>

<span class="c1">// Create a DataSet from a list of elements</span>
<span class="n">DataSet</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">myInts</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="na">fromElements</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">);</span>

<span class="c1">// Create a DataSet from any Java collection</span>
<span class="n">List</span><span class="o">&lt;</span><span class="n">Tuple2</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;&gt;</span> <span class="n">data</span> <span class="o">=</span> <span class="o">...</span>
<span class="n">DataSet</span><span class="o">&lt;</span><span class="n">Tuple2</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;&gt;</span> <span class="n">myTuples</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="na">fromCollection</span><span class="o">(</span><span class="n">data</span><span class="o">);</span>

<span class="c1">// Create a DataSet from an Iterator</span>
<span class="n">Iterator</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">&gt;</span> <span class="n">longIt</span> <span class="o">=</span> <span class="o">...</span>
<span class="n">DataSet</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">&gt;</span> <span class="n">myLongs</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="na">fromCollection</span><span class="o">(</span><span class="n">longIt</span><span class="o">,</span> <span class="n">Long</span><span class="o">.</span><span class="na">class</span><span class="o">);</span></code></pre></figure>

    <p>A collection data sink is specified as follows:</p>

    <figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">DataSet</span><span class="o">&lt;</span><span class="n">Tuple2</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;&gt;</span> <span class="n">myResult</span> <span class="o">=</span> <span class="o">...</span>

<span class="n">List</span><span class="o">&lt;</span><span class="n">Tuple2</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;&gt;</span> <span class="n">outData</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Tuple2</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;&gt;();</span>
<span class="n">myResult</span><span class="o">.</span><span class="na">output</span><span class="o">(</span><span class="k">new</span> <span class="nf">LocalCollectionOutputFormat</span><span class="o">(</span><span class="n">outData</span><span class="o">));</span></code></pre></figure>

    <p><strong>Note:</strong> 目前， coolection data sink只能在本地模式下使用，作为一个debug 工具</p>

  </div>
  <div data-lang="scala">

    <figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">env</span> <span class="k">=</span> <span class="nc">ExecutionEnvironment</span><span class="o">.</span><span class="n">createLocalEnvironment</span><span class="o">()</span>

<span class="c1">// Create a DataSet from a list of elements</span>
<span class="k">val</span> <span class="n">myInts</span> <span class="k">=</span> <span class="n">env</span><span class="o">.</span><span class="n">fromElements</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">)</span>

<span class="c1">// Create a DataSet from any Collection</span>
<span class="k">val</span> <span class="n">data</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[(</span><span class="kt">String</span>, <span class="kt">Int</span><span class="o">)]</span> <span class="k">=</span> <span class="o">...</span>
<span class="k">val</span> <span class="n">myTuples</span> <span class="k">=</span> <span class="n">env</span><span class="o">.</span><span class="n">fromCollection</span><span class="o">(</span><span class="n">data</span><span class="o">)</span>

<span class="c1">// Create a DataSet from an Iterator</span>
<span class="k">val</span> <span class="n">longIt</span><span class="k">:</span> <span class="kt">Iterator</span><span class="o">[</span><span class="kt">Long</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
<span class="k">val</span> <span class="n">myLongs</span> <span class="k">=</span> <span class="n">env</span><span class="o">.</span><span class="n">fromCollection</span><span class="o">(</span><span class="n">longIt</span><span class="o">)</span></code></pre></figure>

  </div>
</div>

<p><strong>Note:</strong> 目前， collection data source 要求数据类型或iterator 实现<code>Serializable</code>。 更进一步说，
collection data sources不能够并行执行（parallelism 被限制为1）</p>

<p><a href="#top" class="top pull-right"><span class="glyphicon glyphicon-chevron-up"></span> Back to top</a></p>

<h2 id="semantic-annotations">Semantic Annotations</h2>

<p>可用用语法注解来提示flink 一个函数的行为特征。 它可用告诉系统输入数据的哪些field 被读取并evaluate， 哪些字段不经修改就直接发送到输出。</p>

<p>语法注解是一个加速执行的有效途径， 因为它允许系统去判断重复使用排序顺序或者在多个操作之间进行partition。 使用语法注解可以节省程序
不必要的shuffle和不必要的sort，显著提高性能。</p>

<p><strong>注意</strong> 使用语法注解是可选的。 保守提供语法注解非常重要。不正确的语法注解会让flink做出错误判断并导致错误结果。
如果一个操作的行为不是很清晰的提起预判， 不要提供语法注解。 请仔细阅读文档。</p>

<p>目前，下面的语法注解是支持的。</p>

<h4 id="forwarded-fields-annotation">Forwarded Fields Annotation</h4>

<p>转发字段注解。 转发字段注解定义了输入对象中哪些字段是在函数中不会被修改，直接转发到output中相同位置或其他位置。</p>

<p>这些信息可用来优化判断在sorting或partition中的数据属性在函数中保留下来。</p>

<p>对于像输入数据像组数据的函数，比如<code>GroupReduce</code>, <code>GroupCombine</code>, <code>CoGroup</code>, and <code>MapPartition</code>， 定义为转发的所有字段必须在相同的输入元素内联合转发。 
由组操作（group-wise）函数发送的每个元素的的转发字段可以由函数的输入group的不同元素来组成。</p>

<p>用<a href="#define-keys-using-field-expressions">field expressions</a>来确定field转发信息。
在output中转发位置相同的filed由它们的位置来确定。
确定的位置必须是input中有效和houtput 中数据类型必须相同
举例来说， “f2”定义了java input tuple中第三个字段， 它同样等同于output tuple中第三个字段。</p>

<p>不做修改直接转发到其他位置的field， 通过“filed express”来定义。 比如”f0-&gt;f2”表示 java input tuple中第一个字段将不做修改直接copy到java 输出的第三个字段。 
“＊”可以表示整个输入或输出， 比如”f0-&gt;*” 表示函数的输出就是等同于java 输入tuple的第一个字段。</p>

<p>可以在一个string中定义多个字段转发 <code>"f0; f2-&gt;f1; f3-&gt;f2"</code>或者多个单独string比如<code>"f0", "f2-&gt;f1", "f3-&gt;f2"</code>。 
注解转发字段并不要求所有的转发字段都被定义， 但所有的定义都必须是正确的。</p>

<p>在函数定义前增加java注解可以用来定义转发字段，或者将它们作为函数参数。</p>

<h5 id="function-class-annotations">Function Class Annotations</h5>

<ul>
  <li><code>@ForwardedFields</code> 用于单一输入的函数比如map或reduce</li>
  <li><code>@ForwardedFieldsFirst</code> 用于2个输入的函数比如join或cogroup的第一个输入</li>
  <li><code>@ForwardedFieldsSecond</code> 用于2个输入的函数比如join或cogroup的第二个输入</li>
</ul>

<h5 id="operator-arguments">Operator Arguments</h5>

<ul>
  <li><code>data.map(myMapFnc).withForwardedFields()</code> 用于单一输入的函数比如map或reduce</li>
  <li><code>data1.join(data2).where().equalTo().with(myJoinFnc).withForwardFieldsFirst()</code> 用于2个输入的函数比如join或cogroup的第一个输入</li>
  <li><code>data1.join(data2).where().equalTo().with(myJoinFnc).withForwardFieldsSecond()</code> 用于2个输入的函数比如join或cogroup的第二个输入</li>
</ul>

<p>注意， 不可能用函数参数的方式来覆盖class 注解定义的转发字段。</p>

<h5 id="example">Example</h5>

<p>The following example shows how to declare forwarded field information using a function class annotation:</p>

<div class="codetabs">
  <div data-lang="java">

    <figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="nd">@ForwardedFields</span><span class="o">(</span><span class="s">&quot;f0-&gt;f2&quot;</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyMap</span> <span class="kd">implements</span>
              <span class="n">MapFunction</span><span class="o">&lt;</span><span class="n">Tuple2</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;,</span> <span class="n">Tuple3</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Integer</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;&gt;</span> <span class="o">{</span>
  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="n">Tuple3</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Integer</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="nf">map</span><span class="o">(</span><span class="n">Tuple2</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">Tuple3</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Integer</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;(</span><span class="s">&quot;foo&quot;</span><span class="o">,</span> <span class="n">val</span><span class="o">.</span><span class="na">f1</span> <span class="o">/</span> <span class="mi">2</span><span class="o">,</span> <span class="n">val</span><span class="o">.</span><span class="na">f0</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

  </div>
  <div data-lang="scala">

    <figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="nd">@ForwardedFields</span><span class="o">(</span><span class="s">&quot;_1-&gt;_3&quot;</span><span class="o">)</span>
<span class="k">class</span> <span class="nc">MyMap</span> <span class="k">extends</span> <span class="nc">MapFunction</span><span class="o">[(</span><span class="kt">Int</span>, <span class="kt">Int</span><span class="o">)</span>, <span class="o">(</span><span class="kt">String</span>, <span class="kt">Int</span>, <span class="kt">Int</span><span class="o">)]{</span>
   <span class="k">def</span> <span class="n">map</span><span class="o">(</span><span class="n">value</span><span class="k">:</span> <span class="o">(</span><span class="kt">Int</span><span class="o">,</span> <span class="kt">Int</span><span class="o">))</span><span class="k">:</span> <span class="o">(</span><span class="kt">String</span><span class="o">,</span> <span class="kt">Int</span><span class="o">,</span> <span class="nc">Int</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">return</span> <span class="o">(</span><span class="s">&quot;foo&quot;</span><span class="o">,</span> <span class="n">value</span><span class="o">.</span><span class="n">_2</span> <span class="o">/</span> <span class="mi">2</span><span class="o">,</span> <span class="n">value</span><span class="o">.</span><span class="n">_1</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

  </div>
</div>

<h4 id="non-forwarded-fields">Non-Forwarded Fields</h4>

<p>定义非转发字段表示这些字段在函数输出相同位置上不再保留。 
其他字段将在输出的相同位置上保留。
因此 非转发字段就是转发字段功能的相反。
在一些组操作（group－wise）函数中，比如<code>GroupReduce</code>, <code>GroupCombine</code>, <code>CoGroup</code>, and <code>MapPartition</code> ， 非转发字段必须实现和转发字段相同的要求。</p>

<p><strong>IMPORTANT</strong> 非转发字段的定义是可选的， 然而， 如果一旦使用， 其他字段就会被定义为forward。 因此相对来说，将一个转发字段定义为非转发字段会更安全一点。</p>

<p>用<a href="#define-keys-using-field-expressions">field expressions</a> list来表示非转发字段。 可以是<code>"f1; f3"</code> 和 <code>"f1", "f3"</code>， 
一个语句多个字段或多个独立语句组成。 非转发字段要求函数输入和输出类型相同。</p>

<p>用类注解的方式定义非转发字段</p>

<ul>
  <li><code>@NonForwardedFields</code> 用于单一输入的函数比如map或reduce</li>
  <li><code>@NonForwardedFieldsFirst</code> 用于2个输入的函数比如join或cogroup的第一个输入</li>
  <li><code>@NonForwardedFieldsSecond</code> 用于2个输入的函数比如join或cogroup的第二个输入</li>
</ul>

<h5 id="example-1">Example</h5>

<p>The following example shows how to declare non-forwarded field information:</p>

<div class="codetabs">
  <div data-lang="java">

    <figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="nd">@NonForwardedFields</span><span class="o">(</span><span class="s">&quot;f1&quot;</span><span class="o">)</span> <span class="c1">// second field is not forwarded</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyMap</span> <span class="kd">implements</span>
              <span class="n">MapFunction</span><span class="o">&lt;</span><span class="n">Tuple2</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;,</span> <span class="n">Tuple2</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;&gt;</span> <span class="o">{</span>
  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="n">Tuple2</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="nf">map</span><span class="o">(</span><span class="n">Tuple2</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">Tuple2</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;(</span><span class="n">val</span><span class="o">.</span><span class="na">f0</span><span class="o">,</span> <span class="n">val</span><span class="o">.</span><span class="na">f1</span> <span class="o">/</span> <span class="mi">2</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

  </div>
  <div data-lang="scala">

    <figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="nd">@NonForwardedFields</span><span class="o">(</span><span class="s">&quot;_2&quot;</span><span class="o">)</span> <span class="c1">// second field is not forwarded</span>
<span class="k">class</span> <span class="nc">MyMap</span> <span class="k">extends</span> <span class="nc">MapFunction</span><span class="o">[(</span><span class="kt">Int</span>, <span class="kt">Int</span><span class="o">)</span>, <span class="o">(</span><span class="kt">Int</span>, <span class="kt">Int</span><span class="o">)]{</span>
  <span class="k">def</span> <span class="n">map</span><span class="o">(</span><span class="n">value</span><span class="k">:</span> <span class="o">(</span><span class="kt">Int</span><span class="o">,</span> <span class="kt">Int</span><span class="o">))</span><span class="k">:</span> <span class="o">(</span><span class="kt">Int</span><span class="o">,</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">return</span> <span class="o">(</span><span class="n">value</span><span class="o">.</span><span class="n">_1</span><span class="o">,</span> <span class="n">value</span><span class="o">.</span><span class="n">_2</span> <span class="o">/</span> <span class="mi">2</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

  </div>
</div>

<h4 id="read-fields">Read Fields</h4>

<p>定义一个函数将会访问并evaluate的读取字段， 举例 函数的所有字段都用来计算结果。
在条件语句中evalue的字段或用来计算结果的字段必须标记为read，当确定读字段信息时。
那些不做修改直接转发给输出的字段或者不访问的字段将不被考虑为读。</p>

<p><strong>IMPORTANT</strong>: 
定义读字段操作是可选的， 然而，一旦使用， 则所有的读字段必须明确。 定义一个非读字段为读其实会比较安全。</p>

<p>Read fields are specified as a list of <a href="#define-keys-using-field-expressions">field expressions</a>. The list can be either given as a single String with field expressions separated by semicolons or as multiple Strings.
For example both <code>"f1; f3"</code> and <code>"f1", "f3"</code> declare that the second and fourth field of a Java tuple are read and evaluated by the function.</p>

<p>Read field information is specified as function class annotations using the following annotations:</p>

<ul>
  <li><code>@ReadFields</code> for single input functions such as Map and Reduce.</li>
  <li><code>@ReadFieldsFirst</code> for the first input of a function with two inputs such as Join and CoGroup.</li>
  <li><code>@ReadFieldsSecond</code> for the second input of a function with two inputs such as Join and CoGroup.</li>
</ul>

<h5 id="example-2">Example</h5>

<p>The following example shows how to declare read field information:</p>

<div class="codetabs">
  <div data-lang="java">

    <figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="nd">@ReadFields</span><span class="o">(</span><span class="s">&quot;f0; f3&quot;</span><span class="o">)</span> <span class="c1">// f0 and f3 are read and evaluated by the function.</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyMap</span> <span class="kd">implements</span>
              <span class="n">MapFunction</span><span class="o">&lt;</span><span class="n">Tuple4</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">Integer</span><span class="o">,</span> <span class="n">Integer</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;,</span>
                          <span class="n">Tuple2</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;&gt;</span> <span class="o">{</span>
  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="n">Tuple2</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="nf">map</span><span class="o">(</span><span class="n">Tuple4</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">Integer</span><span class="o">,</span> <span class="n">Integer</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span><span class="o">(</span><span class="n">val</span><span class="o">.</span><span class="na">f0</span> <span class="o">==</span> <span class="mi">42</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">return</span> <span class="k">new</span> <span class="n">Tuple2</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;(</span><span class="n">val</span><span class="o">.</span><span class="na">f0</span><span class="o">,</span> <span class="n">val</span><span class="o">.</span><span class="na">f1</span><span class="o">);</span>
    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
      <span class="k">return</span> <span class="k">new</span> <span class="n">Tuple2</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;(</span><span class="n">val</span><span class="o">.</span><span class="na">f3</span><span class="o">+</span><span class="mi">10</span><span class="o">,</span> <span class="n">val</span><span class="o">.</span><span class="na">f1</span><span class="o">);</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

  </div>
  <div data-lang="scala">

    <figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="nd">@ReadFields</span><span class="o">(</span><span class="s">&quot;_1; _4&quot;</span><span class="o">)</span> <span class="c1">// _1 and _4 are read and evaluated by the function.</span>
<span class="k">class</span> <span class="nc">MyMap</span> <span class="k">extends</span> <span class="nc">MapFunction</span><span class="o">[(</span><span class="kt">Int</span>, <span class="kt">Int</span>, <span class="kt">Int</span>, <span class="kt">Int</span><span class="o">)</span>, <span class="o">(</span><span class="kt">Int</span>, <span class="kt">Int</span><span class="o">)]{</span>
   <span class="k">def</span> <span class="n">map</span><span class="o">(</span><span class="n">value</span><span class="k">:</span> <span class="o">(</span><span class="kt">Int</span><span class="o">,</span> <span class="kt">Int</span><span class="o">,</span> <span class="nc">Int</span><span class="o">,</span> <span class="nc">Int</span><span class="o">))</span><span class="k">:</span> <span class="o">(</span><span class="kt">Int</span><span class="o">,</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">value</span><span class="o">.</span><span class="n">_1</span> <span class="o">==</span> <span class="mi">42</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">return</span> <span class="o">(</span><span class="n">value</span><span class="o">.</span><span class="n">_1</span><span class="o">,</span> <span class="n">value</span><span class="o">.</span><span class="n">_2</span><span class="o">)</span>
    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
      <span class="k">return</span> <span class="o">(</span><span class="n">value</span><span class="o">.</span><span class="n">_4</span> <span class="o">+</span> <span class="mi">10</span><span class="o">,</span> <span class="n">value</span><span class="o">.</span><span class="n">_2</span><span class="o">)</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

  </div>
</div>

<p><a href="#top" class="top pull-right"><span class="glyphicon glyphicon-chevron-up"></span> Back to top</a></p>

<h2 id="broadcast-variables">Broadcast Variables</h2>

<p>广播变量允许用户在所有的并发实例的函数中操作一个data set。 这种特性对辅助的data set或数据依赖参数信息非常有用。
这个data set在函数中可以成为一个collection。</p>

<ul>
  <li><strong>Broadcast</strong>: 广播set通过<code>withBroadcastSet(DataSet, String)</code>来注册</li>
  <li><strong>Access</strong>: 在一个函数内通过<code>getRuntimeContext().getBroadcastVariable(String)</code>来访问</li>
</ul>

<div class="codetabs">
  <div data-lang="java">

    <figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="c1">// 1. The DataSet to be broadcasted</span>
<span class="n">DataSet</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">toBroadcast</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="na">fromElements</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">);</span>

<span class="n">DataSet</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">data</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="na">fromElements</span><span class="o">(</span><span class="s">&quot;a&quot;</span><span class="o">,</span> <span class="s">&quot;b&quot;</span><span class="o">);</span>

<span class="n">data</span><span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="k">new</span> <span class="n">RichMapFunction</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;()</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">open</span><span class="o">(</span><span class="n">Configuration</span> <span class="n">parameters</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
      <span class="c1">// 3. Access the broadcasted DataSet as a Collection</span>
      <span class="n">Collection</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">broadcastSet</span> <span class="o">=</span> <span class="n">getRuntimeContext</span><span class="o">().</span><span class="na">getBroadcastVariable</span><span class="o">(</span><span class="s">&quot;broadcastSetName&quot;</span><span class="o">);</span>
    <span class="o">}</span>


    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">String</span> <span class="nf">map</span><span class="o">(</span><span class="n">String</span> <span class="n">value</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
        <span class="o">...</span>
    <span class="o">}</span>
<span class="o">}).</span><span class="na">withBroadcastSet</span><span class="o">(</span><span class="n">toBroadcast</span><span class="o">,</span> <span class="s">&quot;broadcastSetName&quot;</span><span class="o">);</span> <span class="c1">// 2. Broadcast the DataSet</span></code></pre></figure>

    <p>必须确保这个名字(在上一例子中<code>broadcastSetName</code> )在注册和使用中，二者是匹配的. 完整的例子可以参考
<a href="https://github.com/apache/flink/blob/master//flink-examples/flink-examples-batch/src/main/java/org/apache/flink/examples/java/clustering/KMeans.java#L96">K-Means Algorithm</a>.</p>
  </div>
  <div data-lang="scala">

    <figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="c1">// 1. The DataSet to be broadcasted</span>
<span class="k">val</span> <span class="n">toBroadcast</span> <span class="k">=</span> <span class="n">env</span><span class="o">.</span><span class="n">fromElements</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>

<span class="k">val</span> <span class="n">data</span> <span class="k">=</span> <span class="n">env</span><span class="o">.</span><span class="n">fromElements</span><span class="o">(</span><span class="s">&quot;a&quot;</span><span class="o">,</span> <span class="s">&quot;b&quot;</span><span class="o">)</span>

<span class="n">data</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">new</span> <span class="nc">RichMapFunction</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">String</span><span class="o">]()</span> <span class="o">{</span>
    <span class="k">var</span> <span class="n">broadcastSet</span><span class="k">:</span> <span class="kt">Traversable</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="kc">null</span>

    <span class="k">override</span> <span class="k">def</span> <span class="n">open</span><span class="o">(</span><span class="n">config</span><span class="k">:</span> <span class="kt">Configuration</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
      <span class="c1">// 3. Access the broadcasted DataSet as a Collection</span>
      <span class="n">broadcastSet</span> <span class="k">=</span> <span class="n">getRuntimeContext</span><span class="o">().</span><span class="n">getBroadcastVariable</span><span class="o">[</span><span class="kt">String</span><span class="o">](</span><span class="s">&quot;broadcastSetName&quot;</span><span class="o">).</span><span class="n">asScala</span>
    <span class="o">}</span>

    <span class="k">def</span> <span class="n">map</span><span class="o">(</span><span class="n">in</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="o">{</span>
        <span class="o">...</span>
    <span class="o">}</span>
<span class="o">}).</span><span class="n">withBroadcastSet</span><span class="o">(</span><span class="n">toBroadcast</span><span class="o">,</span> <span class="s">&quot;broadcastSetName&quot;</span><span class="o">)</span> <span class="c1">// 2. Broadcast the DataSet</span></code></pre></figure>

    <p>必须确保这个名字(在上一例子中<code>broadcastSetName</code> )在注册和使用中，二者是匹配的. 完整的例子可以参考
<a href="https://github.com/apache/flink/blob/master//flink-examples/flink-examples-batch/src/main/java/org/apache/flink/examples/java/clustering/KMeans.java#L96">K-Means Algorithm</a>.</p>
  </div>
</div>

<p><strong>Note</strong>: 
因为broadcaset 变量是维持在每个节点的内存中， 数据量不能太大。 对于一些简单的事情， 用户可以用将函数参数化， 或使用<code>withParameters(...)</code>来在配置中传递。</p>

<p><a href="#top" class="top pull-right"><span class="glyphicon glyphicon-chevron-up"></span> Back to top</a></p>

<h2 id="passing-parameters-to-functions">Passing Parameters to Functions</h2>

<p>传递给函数的参数可以使用构造函数或<code>withParameters(Configuration)</code> 。 这些参数被序列化作为函数对象的部分并被发送到每个task实例</p>

<p>可以查看更多 <a href="/1.1.0/apis/best_practices.html#parsing-command-line-arguments-and-passing-them-around-in-your-flink-application">best practices guide on how to pass command line arguments to functions</a>.</p>

<h4 id="via-constructor">Via Constructor</h4>

<div class="codetabs">
  <div data-lang="java">

    <figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">DataSet</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">toFilter</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="na">fromElements</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">);</span>

<span class="n">toFilter</span><span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="k">new</span> <span class="nf">MyFilter</span><span class="o">(</span><span class="mi">2</span><span class="o">));</span>

<span class="kd">private</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">MyFilter</span> <span class="kd">implements</span> <span class="n">FilterFunction</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="o">{</span>

  <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">limit</span><span class="o">;</span>

  <span class="kd">public</span> <span class="nf">MyFilter</span><span class="o">(</span><span class="kt">int</span> <span class="n">limit</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">limit</span> <span class="o">=</span> <span class="n">limit</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">filter</span><span class="o">(</span><span class="n">Integer</span> <span class="n">value</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">value</span> <span class="o">&gt;</span> <span class="n">limit</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

  </div>
  <div data-lang="scala">

    <figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">toFilter</span> <span class="k">=</span> <span class="n">env</span><span class="o">.</span><span class="n">fromElements</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>

<span class="n">toFilter</span><span class="o">.</span><span class="n">filter</span><span class="o">(</span><span class="k">new</span> <span class="nc">MyFilter</span><span class="o">(</span><span class="mi">2</span><span class="o">))</span>

<span class="k">class</span> <span class="nc">MyFilter</span><span class="o">(</span><span class="n">limit</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">FilterFunction</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">filter</span><span class="o">(</span><span class="n">value</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="o">{</span>
    <span class="n">value</span> <span class="o">&gt;</span> <span class="n">limit</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

  </div>
</div>

<h4 id="via-withparametersconfiguration">Via <code>withParameters(Configuration)</code></h4>

<p>这个函数用一个configuration对象作为参数， 它会被传递给<a href="#rich-functions">rich function</a>’s <code>open()</code>。 configuration对象是一个map， 
key类型是string，value是其他类型。</p>

<div class="codetabs">
  <div data-lang="java">

    <figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">DataSet</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">toFilter</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="na">fromElements</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">);</span>

<span class="n">Configuration</span> <span class="n">config</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">Configuration</span><span class="o">();</span>
<span class="n">config</span><span class="o">.</span><span class="na">setInteger</span><span class="o">(</span><span class="s">&quot;limit&quot;</span><span class="o">,</span> <span class="mi">2</span><span class="o">);</span>

<span class="n">toFilter</span><span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="k">new</span> <span class="n">RichFilterFunction</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;()</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">limit</span><span class="o">;</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">open</span><span class="o">(</span><span class="n">Configuration</span> <span class="n">parameters</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
      <span class="n">limit</span> <span class="o">=</span> <span class="n">parameters</span><span class="o">.</span><span class="na">getInteger</span><span class="o">(</span><span class="s">&quot;limit&quot;</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">filter</span><span class="o">(</span><span class="n">Integer</span> <span class="n">value</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
      <span class="k">return</span> <span class="n">value</span> <span class="o">&gt;</span> <span class="n">limit</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}).</span><span class="na">withParameters</span><span class="o">(</span><span class="n">config</span><span class="o">);</span></code></pre></figure>

  </div>
  <div data-lang="scala">

    <figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">toFilter</span> <span class="k">=</span> <span class="n">env</span><span class="o">.</span><span class="n">fromElements</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>

<span class="k">val</span> <span class="n">c</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Configuration</span><span class="o">()</span>
<span class="n">c</span><span class="o">.</span><span class="n">setInteger</span><span class="o">(</span><span class="s">&quot;limit&quot;</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span>

<span class="n">toFilter</span><span class="o">.</span><span class="n">filter</span><span class="o">(</span><span class="k">new</span> <span class="nc">RichFilterFunction</span><span class="o">[</span><span class="kt">Int</span><span class="o">]()</span> <span class="o">{</span>
    <span class="k">var</span> <span class="n">limit</span> <span class="k">=</span> <span class="mi">0</span>

    <span class="k">override</span> <span class="k">def</span> <span class="n">open</span><span class="o">(</span><span class="n">config</span><span class="k">:</span> <span class="kt">Configuration</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
      <span class="n">limit</span> <span class="k">=</span> <span class="n">config</span><span class="o">.</span><span class="n">getInteger</span><span class="o">(</span><span class="s">&quot;limit&quot;</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span>
    <span class="o">}</span>

    <span class="k">def</span> <span class="n">filter</span><span class="o">(</span><span class="n">in</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="o">{</span>
        <span class="n">in</span> <span class="o">&gt;</span> <span class="n">limit</span>
    <span class="o">}</span>
<span class="o">}).</span><span class="n">withParameters</span><span class="o">(</span><span class="n">c</span><span class="o">)</span></code></pre></figure>

  </div>
</div>

<h4 id="globally-via-the-executionconfig">Globally via the <code>ExecutionConfig</code></h4>

<p>flink 同样允许传递实现<code>ExecutionConfig</code>接口的自定义对象到环境中。 这个执行config在所有的rich 用户函数中都是可以访问的， 它是所有函数都可以获取。</p>

<p><strong>Setting a custom global configuration</strong></p>

<div class="codetabs">
  <div data-lang="java">

    <figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">Configuration</span> <span class="n">conf</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">Configuration</span><span class="o">();</span>
<span class="n">conf</span><span class="o">.</span><span class="na">setString</span><span class="o">(</span><span class="s">&quot;mykey&quot;</span><span class="o">,</span><span class="s">&quot;myvalue&quot;</span><span class="o">);</span>
<span class="kd">final</span> <span class="n">ExecutionEnvironment</span> <span class="n">env</span> <span class="o">=</span> <span class="n">ExecutionEnvironment</span><span class="o">.</span><span class="na">getExecutionEnvironment</span><span class="o">();</span>
<span class="n">env</span><span class="o">.</span><span class="na">getConfig</span><span class="o">().</span><span class="na">setGlobalJobParameters</span><span class="o">(</span><span class="n">conf</span><span class="o">);</span></code></pre></figure>

  </div>
  <div data-lang="scala">

    <figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">env</span> <span class="k">=</span> <span class="nc">ExecutionEnvironment</span><span class="o">.</span><span class="n">getExecutionEnvironment</span>
<span class="k">val</span> <span class="n">conf</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Configuration</span><span class="o">()</span>
<span class="n">conf</span><span class="o">.</span><span class="n">setString</span><span class="o">(</span><span class="s">&quot;mykey&quot;</span><span class="o">,</span> <span class="s">&quot;myvalue&quot;</span><span class="o">)</span>
<span class="n">env</span><span class="o">.</span><span class="n">getConfig</span><span class="o">.</span><span class="n">setGlobalJobParameters</span><span class="o">(</span><span class="n">conf</span><span class="o">)</span></code></pre></figure>

  </div>
</div>

<p>可以通过一个继承<code>ExecutionConfig.GlobalJobParameters</code>类的自定义configuration。它的内容同样可以在web ui上显示</p>

<p><strong>Accessing values from the global configuration</strong></p>

<p>在系统中很多地方可以访问全局任务参数对象。 所有实现<code>Rich*Function</code> 接口的函数都可以访问这些对象通过runtime 的context。</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">Tokenizer</span> <span class="kd">extends</span> <span class="n">RichFlatMapFunction</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Tuple2</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;&gt;</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="n">String</span> <span class="n">mykey</span><span class="o">;</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">open</span><span class="o">(</span><span class="n">Configuration</span> <span class="n">parameters</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
      <span class="kd">super</span><span class="o">.</span><span class="na">open</span><span class="o">(</span><span class="n">parameters</span><span class="o">);</span>
      <span class="n">ExecutionConfig</span><span class="o">.</span><span class="na">GlobalJobParameters</span> <span class="n">globalParams</span> <span class="o">=</span> <span class="n">getRuntimeContext</span><span class="o">().</span><span class="na">getExecutionConfig</span><span class="o">().</span><span class="na">getGlobalJobParameters</span><span class="o">();</span>
      <span class="n">Configuration</span> <span class="n">globConf</span> <span class="o">=</span> <span class="o">(</span><span class="n">Configuration</span><span class="o">)</span> <span class="n">globalParams</span><span class="o">;</span>
      <span class="n">mykey</span> <span class="o">=</span> <span class="n">globConf</span><span class="o">.</span><span class="na">getString</span><span class="o">(</span><span class="s">&quot;mykey&quot;</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="c1">// ... more here ...</span></code></pre></figure>

<p><a href="#top" class="top pull-right"><span class="glyphicon glyphicon-chevron-up"></span> Back to top</a></p>

      <div class="footer">
      发现错误？想参与编辑？
      <a href="https://github.com/flink-china/flink-china-doc/edit/1.1.0/apis/batch/index.md" target="_blank">
        在 Github 上编辑此页！
      </a>
    </div>
    </div>
  </div>

  
</div>

    </div><!-- /.container -->

    <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
    <script src="//cdn.bootcss.com/jquery/1.11.2/jquery.min.js"></script>
    <!-- Include all compiled plugins (below), or include individual files as needed -->
    <script src="//cdn.bootcss.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
    <script src="//cdn.bootcss.com/anchor-js/3.1.0/anchor.min.js"></script>
    <script src="/1.1.0/page/js/flink.js"></script>

    <!-- Google Analytics -->
    <!-- script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-52545728-1', 'auto');
      ga('send', 'pageview');
    </script -->

    <!-- Baidu Analytics -->
    <script>
      var _hmt = _hmt || [];
      (function() {
        var hm = document.createElement("script");
        hm.src = "//hm.baidu.com/hm.js?835985ad7943d8c24bc3c1f155b7d4a2";
        var s = document.getElementsByTagName("script")[0]; 
        s.parentNode.insertBefore(hm, s);
      })();
    </script>


    <!-- Disqus -->
    
  </body>
</html>
